\documentclass[english]{article}

% Packages
\usepackage[T1]{fontenc}
\usepackage[hyphens]{url}
\usepackage[bookmarks]{hyperref}
\usepackage{graphicx}
\usepackage{verbatim}
\hypersetup{
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black
}
% \usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage{cite}

% listings settings
\usepackage{listings}
\lstset{
  float,
  title={\ttfamily\small Sage},
  gobble=3,
  language=Python,
  basicstyle=\ttfamily\footnotesize,
  %numbers=left,
  %numberstyle=\tiny,
  %numbersep=5pt,
  frame=single,
  tabsize=2,
  breaklines=true,
}

% Definitions
\def\qqq{\mathbb{Q}}
\def\rrr{\mathbb{R}}
\def\zzz{\mathbb{Z}}
\def\fff{\mathbb{F}}
\def\gftwo{\mathbb{F}_2}
\def\zzzp{\mathbb{Z}_p}
\def\zzzn{\mathbb{Z}_N}
\def\zg{\mathbb{Z}_g}
\def\nnn{\mathbb{N}}
\def\BF{\mathcal{BF}}
\def\xn{(x_n)}
\def\yn{(y_n)}
\def\zn{(z_n)}
\def\an{(a_n)}
\def\Chi{\raisebox{2pt}{$\chi$}}
% \def\qed{$\Box}
% \newcounter{padic}
%\newcounter{examples}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{corollary}[theorem]{Corollary}%[section]
\newtheorem{lemma}[theorem]{Lemma}%[section]
\newtheorem{proposition}[theorem]{Proposition}%[section]

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}%[section]
\newtheorem{example}[theorem]{Example}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}%[section]

\begin{document}

\title{Feedback with Carry Shift Registers and Bent Sequences}
\author{MIDN 1/C Charles Celerier}

\maketitle

\begin{abstract}
  A stream cipher uses pseudorandom sequences to mimic the security of a
  one-time pad. This paper will investigate how bent functions can be used
  to generate $f$-filtered bent sequences with large 2-adic valuation.
  Rearrangements of these sequences could be effective for filtering the states
  of feedback with carry shift registers (FCSRs) in stream ciphers. The
  non-linearity of $f$-filtered bent sequences could provide resistance
  for FCSR-based stream ciphers in register synthesis attacks. In this paper, we
  show that it is possible to compute the 2-adic valuation of a bent
  sequence generated by a Maiorana-McFarland class Boolean function.
\end{abstract}


\section{Introduction}\label{sec:intro}
\par Bytes of data, or short sequences of 1s and 0s, are exchanged between
computer systems each day on public channels. Because gentlemen do read each
other's mail, it is necessary to secure the communication of private data
sent over public channels. The solution to this problem is solved by
{\em cryptography}, the designing of systems to secure data exchanges over
public channels.

\par The following example is the classical communication scenario presented
in many books on cryptography. Let there be two parties, Alice and Bob, who
wish to communicate with one another. A third party, Eve, is a potential
eavesdropper. Alice wants to send a message, known as the {\em plaintext},
to Bob. To accomplish this without Eve knowing what the message is before it
is received by Bob, Alice must {\em encrypt} her message by some prearranged
method, usually involving an {\em encryption key}, to generate a related
message called {\em ciphertext}. The idea is that the sent ciphertext, even
if it is intercepted by Eve, will be too difficult to interpret and will
conceal the plaintext message. Upon receipt of the ciphertext, Bob will
{\em decrypt} the message, usually involving a {\em decryption key}, similar
to the encryption of the message, and obtain the plaintext message. A visual
of this scenario is presented in Figure \ref{fig:basic-scenario}.

\begin{figure}[h!]\label{fig:basic-scenario}
	\centering
  %% The Basic Communication Scenario for Cryptography
  \setlength{\unitlength}{1mm}
  \begin{picture}(100,38)(-50,-19)
    \put(-50,-1.3){\framebox{Alice}}
    \put(0,0){\circle*{2}}
    \put(-39.9,0){\vector(4,0){15}}
    \put(-24.9,-1){\framebox{Encrypt}}
    \put(-10,0){\line(4,0){9}}
    \put(-38.4,2){\makebox{\footnotesize plaintext}}
    \put(-17.45,15){\vector(0,-4){12.2}}
    \put(-24,20){\makebox{\footnotesize encryption}}
    \put(-19.5,16.5){\makebox{\footnotesize key}}
    \put(-6.5,2){\makebox{\footnotesize ciphertext}}
    \put(1,0){\vector(4,0){9}}
    \put(0,-1){\vector(0,-4){12.2}}
    \put(-4.2,-17){\framebox{Eve}}
    \put(0,-13.2){\vector(0,4){12.2}}
    \put(10,-1){\framebox{Decrypt}}
    \put(24.9,0){\vector(4,0){15}}
    \put(26.1,2){\footnotesize plaintext}
    \put(39.9,-1.3){\framebox{Bob}}
    \put(17.45,15){\vector(0,-4){12.2}}
    \put(11,20){\makebox{\footnotesize decryption}}
    \put(15.5,16.5){\makebox{\footnotesize key}}
  \end{picture}
	\caption{The basic communication scenario for cryptography}
\end{figure}

\par This scenario is the standard example found in many different
introductory cryptography references. Cryptographers have created numerous
encryption and decryption schemes, or {\em cryptosystems}, to secure the
messages sent between Alice and Bob. Many of these systems have been broken
because of the amount of work that goes into the study of breaking
cryptosystems, called {\em cryptanalysis}. A constant battle exists between
the designers and breakers of cryptosystems, strengthening designs and
attacks every day. In fact, designing a strong cryptosystem typically
requires knowledge of cryptography and cryptanalysis. When designing a
cryptosystem, every cryptographer assumes {\em Kerckhoffs' principle}
\cite{bk:tw06}: ``In assessing the security of a cryptosystem, one should always
assume the enemy knows the method being used.'' The security of a cryptosystem
cannot be based on the concealment of the encryption and decryption algorithms.
In practice, the enemy can obtain the algorithms in many ways, including the
defection or capture of people. The security must be based solely on the key.

\par This paper will explore bent sequences for their potential strength in
{\it stream ciphers}. According to Rueppel in \cite{bk:r86}, a {\em stream cipher}
divides bit sequences into individual bits and enciphers each bit with a
time-varying function whose time-dependency is governed by the internal state
of the stream cipher.  The stream cipher can also be thought of in terms of a
{\em keystream} which is a sequence of 1s and 0s the same length of the
message that is added to the message using addition in $\gftwo$ (also known
as XOR). If the keystream was perfectly random, then the cryptosystem would
be unbreakable, or {\em perfectly secret}, as discovered by Claude Shannon
in his famous paper ``Communication Theory of Secrecy Systems,'' written
secretly in 1945 and published in 1949. This cryptosystem is known as the
{\em one-time pad}. Though it is perfectly secret, it can be difficult to
implement because of the inability to produce perfectly random keystreams.
Constructing a method to produce perfectly random sequences is a
contradiction in itself.

\par Though it is difficult to create perfectly random sequences, it is feasible
to get close. A sequence which is close to being random is called a
{\em pseudorandom sequence}. In \cite{bk:g82}, Golomb lists three randomness
postulates on periodic binary sequences:
\begin{enumerate}[R-1.]
	\item In every period, the number of 0s is nearly equal to the number of 1s.
	\item In every period, half the runs have length one, one-fourth have length
		two, one-eighth have length three, etc., as long as the number of runs so
		indicated exceeds 1. Moreover, for each of these lengths, there are equally
		many runs of 0s and of 1s.
	\item The auto-correlation function $C(\tau)$ is two-valued. Explicitly
		\begin{align*}
      C(\tau)=\frac{1}{p}\sum_{n=1}^p(-1)^{a_na_{n+\tau}}=
			\begin{cases}
				1 \text{if } \tau=0,\\
				K \text{if } 0<\tau<p.
			\end{cases}
		\end{align*}
\end{enumerate}
These postulates today have become a measure of how close a sequence is to being
considered pseudorandom. The claim is that binary sequences with extremely long
periods would be nearly indistinguishable from perfectly random binary
sequences.
\par In the case of this paper, the {\it $f$-filtered Boolean sequence} defined
in Section~\ref{sec:boolean-sequences} is considered in the context of
pseudorandom sequences and FCSRs. The main result is the calculated 2-adic
valuation of $f$-filtered bent sequences generated by the Maiorana-McFarland
class of Boolean functions.
\par In Section~\ref{sec:boolean-functions}, Boolean
functions are first introduced, and the section concludes with the definition of
the Walsh transform and bent functions. In Section~\ref{sec:n-adic-ring}, the
$N$-adic ring is defined and a few properties of $2$-adic sequences are
discussed. The $2$-adic valuation defined in this section is critical to
understanding the main result in Section~\ref{sec:boolean-sequences}. Section
\ref{sec:shift-registers} defines the FCSR following a fundamental discussion on
finite state machines and $n$-state shift registers. Two shift register
synthesis algorithms are given to demonstrate the necessity of adding a
non-linear component to an FCSR before using it as a secure stream cipher. Finally,
Section~\ref{sec:boolean-sequences} defines what this paper calls {\it
$f$-filtered Boolean sequences} and proves the main result on the $2$-adic
valuation of bent sequences generated by the functions in the Maiorana-McFarland
class.
\par Most of the examples in this paper are shown using {\ttfamily Sage v4.8}.
Methods for the examples are from the class {\ttfamily
sage.crypto.boolean\_functions} which comes with the current version of
{\ttfamily Sage}. In addition, the script {\ttfamily afsr.sage} is attached for
using many of the custom functions written for this paper. This script is
available at:\\
\,\\
\url{https://github.com/celerier/oslo/blob/master/sage/afsr.sage}\,.

\vskip 0.2in
\noindent {\it Acknowledgments:} I thank Professor David Joyner for his
advice and expertise which allowed me to write this paper. Without his help,
this work would not have been possible. I would also like to thank
Professor Mark Goresky of the Princeton Institute for Advanced Study for
his kind encouragement and for suggesting the problem addressed by the
main result of this thesis. I also thank the Math Department for travel
funds to attend the National Conference for Undergraduate Research at
Weber State University in Ogden, Utah.

\section{Boolean Functions}\label{sec:boolean-functions}
\par This section will establish the definition of a Boolean function
and how to write these functions as polynomials. The goal is to introduce the
Walsh transform, and important tools used in cryptography. The Walsh transform
measures the non-linearity of a Boolean function. This section concludes with
the definition of bent functions which in terms of the Walsh transform are
``perfectly non-linear'' Boolean functions. The definitions and
notations will follow those found in \cite{bk:cs09}.

\subsection{Review of Boolean Functions}
\par The two element field $(\gftwo,\oplus,\cdot)$ is the set $\{0,1\}$
with defined binary operations $\oplus$ and $\cdot$, also commonly referred
to as the logical {\em XOR} and {\em AND} operators respectively.
\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    XOR&AND\\
    \hline
    $0\oplus0:=0$&$0\cdot0:=0$\\
    $0\oplus1:=1$&$0\cdot1:=0$\\
    $1\oplus0:=1$&$1\cdot0:=0$\\
    $1\oplus1:=0$&$1\cdot1:=1$\\
    \hline
  \end{tabular}
  \caption{Binary Operations for $\gftwo$}
  \label{tab:GF(2)}
\end{table}
\par It should be clear that $(\gftwo,\oplus,\cdot)$ is a commutative ring
with an identity. Additionally, the only non-zero element $1$ is its own
inverse. In fact, $(\gftwo,\oplus,\cdot)$ is a finite field, which will now
be denoted by $\gftwo$. The $n$-dimensional vector space over $\gftwo$ will
be denoted by $\gftwo^n$, with the usual inner product. Components of vectors in
$\gftwo^n$ will be known as {\em bits}.
For two vectors $x,y\in\gftwo^n$ where $x=(x_0,\dots,x_{n-1})$ and
$y=(y_0,\dots,y_{n-1})$, the inner product in $\gftwo^n$ will be defined
as $x\cdot y:=\allowbreak x_0\cdot y_0 \oplus\allowbreak
\cdots \oplus\allowbreak x_{n-1}\cdot y_{n-1}$.

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^3
    sage: a=V([1,0,1]); b=V([0,1,1]);
    sage: a+b
    (1, 1, 0)
    sage: a.dot_product(b)
    1
  \end{lstlisting}
%  Let $a,b\in\gftwo^3$ such that $a=(1,0,1)$ and $b=(0,1,1)$ then
%  \begin{align*}
%    a+b      &=(1\oplus0,0\oplus1,1\oplus1)=(1,1,0) \\
%    a\cdot b &=1\cdot0\oplus0\cdot1\oplus1\cdot1=1
%  \end{align*}
\end{example}

\par Each vector in $\gftwo^n$ can be uniquely represented by an integer
between $0$ and $2^n-1$. To do this, the components of each vector in
$\gftwo^n$ are trivially mapped to the integers 0 and 1, and then used in
the one-to-one binary representation function $B$:
\begin{equation}
  B:\gftwo^n\rightarrow\{0,\dots,n-1\}\ \allowbreak
  {\rm such\ that }\ \allowbreak B(u) := \sum_{i=0}^{n-1}u_i\cdot2^i.
\end{equation}

\par If we define the vectors $v_i\in\gftwo^n$ by $v_i=B^{-1}(i)$
for $0\leq i\leq2^{n-1}$, then the sequence $(v_0,v_1,\allowbreak \dots,
\allowbreak v_{2^n-1})$ is said to be in {\em binary order}. This
ordering is the standard ordering used by Sage to list vectors in $\gftwo^n$.

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^3
    sage: V.list()
    [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1, 1)]
    sage: [GFn_to_integer(v) for v in V]
    [0, 1, 2, 3, 4, 5, 6, 7]
  \end{lstlisting}
\end{example}

\par This definition of $B$ has created the convention where the
{\em least significant bit} appears on the left and the 
{\em most significant bit} appears on the right. The {\it Hamming weight}
and {\it Hamming distance} functions are used to count the number of 1s in a
vector and count the number of differences between two vectors in
$\gftwo^n$. These are fundmental functions in coding theory and are useful
when talking about Boolean functions.

\begin{definition}\label{def:Hamming}
  Let $x,y\in\gftwo^n$. Then $wt:\gftwo^n\rightarrow\{0,\dots,n-1\}$
  is defined by
  \[
    {\rm wt}(x):=\sum_{i=0}^{n-1}x_i
  \]
  and $d:\gftwo^n\times\gftwo^n\rightarrow\{0,\dots,n-1\}$ is defined by
  \[
    d(x,y):={\rm wt}(x+y).
  \]
  Then ${\rm wt}(x)$ is the {\em Hamming\ weight} of $x$ and $d(x,y)$ is the
  {\em Hamming\ distance} between $x$ and $y$.
\end{definition}

\begin{definition}
\label{def:support}
  Let $x\in\gftwo^n$. Then ${\rm supp}:\gftwo^n\rightarrow\allowbreak
  2^{\{0,\dots,n-1\}}$ is defined by
  \[
    {\rm supp}(x):=\{i\in\{0,\dots,n-1\}:x_i=1\}
  \]
\end{definition}

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^5
    sage: a=V([0,1,1,0,1]); b=V([0,0,1,1,0])
    sage: Hamming_weight(a)
    3
    sage: Hamming_weight(b)
    2
    sage: a.support()
    [1, 2, 4]
    sage: b.support()
    [2, 3]
    sage: Hamming_weight(a+b)
    3
  \end{lstlisting}

%  Let $a,b,c\in\gftwo^5$ such that
%  \[
%  a=(0,1,1,0,1),\ b=(1,1,1,0,0),\ {\rm and}\ c=(0,0,1,1,0).
%  \]
%  Then,
%  \begin{center}
%    \begin{tabular}{c c c}
%      ${\rm wt}(a)=3$&${\rm supp}(a)=\{1,2,4\}$&$d(a,b)=2$\\
%      ${\rm wt}(b)=3$&${\rm supp}(b)=\{0,1,2\}$&$d(a,c)=3$\\
%      ${\rm wt}(c)=2$&$ {\rm supp}(c)=\{2,3\}$ &$d(b,c)=3$.\\
%    \end{tabular}
%  \end{center}
\end{example}

\par There is an interesting orthogonality property in the vector space
$\gftwo^n$ known as the {\em orthogonality principle} that every non-zero
vector in $\gftwo^n$ is orthogonal to exactly half of the vectors in the
vector space.

\begin{proposition}
\label{prop:orthogonality-principle}
  Let $x\in\gftwo^n$. Then
  \begin{equation*}
    \sum_{y\in\gftwo^n}(-1)^{x\cdot y}=
    \begin{cases}
      2^n \text{ \rm for } x=0, \\
      0 \text{ \rm otherwise.}
    \end{cases}
  \end{equation*}
\end{proposition}

\begin{proof}
  Let $x=0\in\gftwo^n$. Then $\forall y\in\gftwo^n$, $x\cdot y=0$, so
  $(-1)^{x\cdot y}=1$. Therefore, $\sum_{y\in\gftwo^n}(-1)^{x\cdot y}=
  \allowbreak\lvert\gftwo^n\rvert=\allowbreak 2^n$. \\

  Let $x\in\gftwo^n$ where $x\not=0$. Assume the $i$th bit of $x$ is
  non-zero and define $e_i\in\gftwo^n$ as a vector with all zero bits
  except for the $i$th bit which is $1$. Then
  \begin{align*}
    \sum_{y\in\gftwo^n}(-1)^{x\cdot y}
      &= \sum_{y\in\gftwo^n}(-1)^{x\cdot (y+e_i)} \\
      &= \sum_{y\in\gftwo^n}(-1)^{x\cdot y}(-1)^{x\cdot e_i} \\
      &= -\sum_{y\in\gftwo^n}(-1)^{x\cdot y}.
  \end{align*}
  Therefore, $\sum_{y\in\gftwo^n}(-1)^{x\cdot y}=\allowbreak
  -\sum_{y\in\gftwo^n}(-1)^{x\cdot y}$, which implies
  \[
  \sum_{y\in\gftwo^n}(-1)^{x\cdot y}=0.
  \]
\end{proof}

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^6
    sage: [sum([(-1)^(x.dot_product(y)) for y in V]) for x in V]
    [64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  \end{lstlisting}
\end{example}

\par When introduced to a new vector space, it is natural to begin looking
at functions in that field. The particular functions of interest here will
be what are known as {\em Boolean functions}.

\begin{definition}
\label{def:boolean-function}
  Any function $f$ defined such that 
  \begin{equation*}
    f:\gftwo^n\rightarrow\gftwo
  \end{equation*}
  is a {\em Boolean function}. The set of all Boolean functions on $n$
  variables will be denoted by $\BF_n$.
\end{definition}

\par The number of Boolean functions increases extremely rapidly as the
number of variables increases.\footnote{With today's fastest supercomputer
operating at 10.51 petaflops (the K computer in Japan), if one floating
point operation was expended visiting every Boolean function of 7 variables,
it would take over a thousand trillion years to complete the process. This
length of time is roughly 70,000 times the age of the universe. Though
every symmetric cryptosystem in use can be broken down into several Boolean
functions of several variables, it would be infeasible to brute force search
through all of the possibilities of Boolean functions which reconstruct the
cryptosystem.}

\begin{equation}
  \lvert\BF_n\rvert = 2^{2^n}
\end{equation}

\par The Boolean function $f$ is presented in a {\em truth\ table} in 
Table \ref{tab:truth-table}. The Hamming weight of $f$ is the number of 1s
that $f$ has when evaluated at every point in the $\gftwo^n$: 
\[
{\rm wt}(f)=\lvert\{u\in\gftwo^n:f(u)=1\}\rvert.
\]
\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c||c|}
    \hline
    $x_0$&$x_1$&$x_2$&$x_3$&$f(x_0,x_1,x_2,x_3)$\\
    \hline
    0&0&0&0&0\\
    1&0&0&0&1\\
    0&1&0&0&1\\
    1&1&0&0&0\\
    0&0&1&0&1\\
    1&0&1&0&0\\
    0&1&1&0&1\\
    1&1&1&0&0\\
    0&0&0&1&0\\
    1&0&0&1&0\\
    0&1&0&1&1\\
    1&1&0&1&0\\
    0&0&1&1&0\\
    1&0&1&1&0\\
    0&1&1&1&1\\
    1&1&1&1&1\\
    \hline
  \end{tabular}
  \caption{Truth Table of $f$}
  \label{tab:truth-table}
\end{table}

\subsection{Boolean Polynomials}
\par A truth table is not a very compact method to define a Boolean
function. It is much more efficient and easier to implement a Boolean
function when written as a formula. This can be done by writing a Boolean
function algebraically. As a first step toward defining $f$ algebraically a
one-to-one and onto function will be defined which maps every $f$ in
$\BF_n$ to a vector in $\gftwo^{2^n}$. This will be the function
$V:\BF_n\rightarrow\gftwo^{2^n}$ such that
\begin{equation}\label{eqn:bool-vector}
  V(f)
    :=(f(v_0),\dots,f(v_{2^n-1}))\ {\rm where\ } v_i=B^{-1}(i).
\end{equation}
It is trivial to show that addition is homomorphic under $V$,
\[
V(f_1\oplus f_2)=V(f_1)\oplus V(f_2).
\]
Then the standard basis of $\gftwo^{2^n}$ can be used to pull back to an
equivalent basis of $\BF_n$. Let $e_i\in\gftwo^{2^n}$ be defined so that
\begin{align*}
  e_0&=(1,0,\dots)\\
  e_1&=(0,1,\dots)\\
  \vdots \\
  e_{2^n-1}&=(0,\dots,0,1).
\end{align*}
\par The {\em atomic Boolean functions} will be defined as the
$f_i\in\BF_n$ where there exists an $e_i\in\gftwo^{2^n}$ such that
$V(f_i)=e_i$. Every vector of $\gftwo^{2^n}$ can be written as a linear
combination of the standard basis vectors, and equivalently, every Boolean
function is a linear combination of atomic Boolean functions. This means
for every $u\in\gftwo^{2^n}$ there exists a set of $c_i\in\gftwo$ such that
\begin{align*}
  u  &=c_0e_0\oplus\cdots\oplus c_{2^n-1}e_{2^n-1} \\
  \Leftrightarrow f &=c_0f_0\oplus\cdots\oplus c_{2^n-1}f_{2^n-1}.\\
\end{align*}
where $V(f)=u$.

\par The function $f$ defined in Table \ref{tab:truth-table} can be written
as a linear combination of the atomic Boolean functions in $\BF_4$. Since
the coefficients in the linear combinations are either 0 or 1, it is true
that every Boolean function can be written as the sum of ${\rm wt}(f)$ atomic
Boolean functions.
\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|c|c||c|c|c|c|c|c|c|c|}
    \hline
    $x_0$&$x_1$&$x_2$&$x_3$
      &$f$&$f_1$&$f_2$&$f_4$&$f_6$&$f_{10}$&$f_{14}$&$f_{15}$\\
    \hline
    0&0&0&0&0&0&0&0&0&0&0&0\\
    1&0&0&0&1&1&0&0&0&0&0&0\\
    0&1&0&0&1&0&1&0&0&0&0&0\\
    1&1&0&0&0&0&0&0&0&0&0&0\\
    0&0&1&0&1&0&0&1&0&0&0&0\\
    1&0&1&0&0&0&0&0&0&0&0&0\\
    0&1&1&0&1&0&0&0&1&0&0&0\\
    1&1&1&0&0&0&0&0&0&0&0&0\\
    0&0&0&1&0&0&0&0&0&0&0&0\\
    1&0&0&1&0&0&0&0&0&0&0&0\\
    0&1&0&1&1&0&0&0&0&1&0&0\\
    1&1&0&1&0&0&0&0&0&0&0&0\\
    0&0&1&1&0&0&0&0&0&0&0&0\\
    1&0&1&1&0&0&0&0&0&0&0&0\\
    0&1&1&1&1&0&0&0&0&0&1&0\\
    1&1&1&1&1&0&0&0&0&0&0&1\\
    \hline
  \end{tabular}
  \caption{$f$ broken into atomic Boolean function in $\BF_4$}
  \label{tab:atomic-f}
\end{table}
\par The equation $f=f_1+f_2+f_4+f_6+f_{10}+f_{14}+f_{15}$ should be clear
from Table \ref{tab:atomic-f}. Knowing how to write the atomic Boolean
functions as polynomials would lead to knowing how to write any Boolean
function as a polynomial. The polynomials representing the Boolean functions
will belong to the the polynomial ring $\gftwo[x_0,\dots,x_{n-1}]/
(x_0^2\oplus x_0,\dots,x_{n-1}^2\oplus x_{n-1})$. To properly represent
an atomic Boolean function, a polynomial must equal 1 at only one vector
$(x_0,\dots,x_{n-1})$. Recall the support function from Definition
\ref{def:support}. Then the polynomial respresenting each Boolean function
is as follows:
\begin{equation}\label{eqn:atomic-ANF}
  f_i=\bigg(\prod_{j\in {\rm supp}(B^{-1}(i))}x_j\bigg)
    \bigg(\prod_{j\not\in {\rm supp}(B^{-1}(i))}(1\oplus x_j)\bigg).
\end{equation}
\begin{proof}
  Let $x=B^{-1}(i)$ where $x=(x_0,\dots,x_{n-1})$. Then
  $\{x_i:x_i=1\}=\{x_i:i\in {\rm supp}(x)\}$. Therefore,
  \[
  f_i(x)=\bigg(\prod_{j\in {\rm supp}(B^{-1}(i))}x_j\bigg)
    \bigg(\prod_{j\not\in {\rm supp}(B^{-1}(i))}(1\oplus x_j)\bigg)=1.
  \]

  Let $x\not=B^{-1}(i)$. Then,
  \[
  \bigg(\prod_{j\in {\rm supp}(B^{-1}(i))}x_j\bigg)=0
  \]\[
  \therefore f_i(x)=0.
  \]
\end{proof}

\par Now the function $f$ from Table \ref{tab:truth-table} can be written as
the sum of the following atomic polynomials:
\begin{align*}
  f_1   &=(1\oplus x_3)(1\oplus x_2)(1\oplus x_1)x_0\\
        &=x_0 \oplus x_1x_0 \oplus x_2x_0 \oplus x_2x_1x_0 \oplus
          x_3x_0 \oplus x_3x_1x_0 \oplus x_3x_2x_0 \oplus x_3x_2x_1x_0\\
  f_2   &=(1\oplus x_3)(1\oplus x_2)x_1(1\oplus x_0)\\
  f_4   &=(1\oplus x_3)x_2(1\oplus x_1)(1\oplus x_0)\\
  f_6   &=(1\oplus x_3)x_2x_1(1\oplus x_0)\\
  f_{10}&=x_3(1\oplus x_2)x_1(1\oplus x_0)\\
  f_{14}&=x_3x_2x_1(1\oplus x_0)\\
  f_{15}&=x_3x_2x_1x_0
\end{align*}
\par After summing the atomic polynomials upon multiplying them out,
\[
  f=x_0x_1x_2x_3\oplus x_0x_1x_3 \oplus x_0x_3 \oplus x_0 \oplus x_1x_2x_3
    \oplus x_1x_2\oplus x_1\oplus x_2x_3 \oplus x_2.
\]
This result is easily verified in Sage:
\begin{lstlisting}[gobble=1]
  sage: f=BooleanFunction([0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1])
  sage: f.algebraic_normal_form()
  x0*x1*x2*x3 + x0*x1*x3 + x0*x3 + x0 + x1*x2*x3 + x1*x2 + x1 + x2*x3 + x2
\end{lstlisting}

\par Now the uniqueness of the polynomial representation for each Boolean
function is considered. This is easily seen by considering the uniqueness of
each Boolean function and the size of the polynomial ring.

\begin{theorem}
Each $n$-variable Boolean function is uniquely represeneted as a polynomial
in the polynomial ring $\gftwo[x_0,\dots,x_{n-1}]/ (x_0^2\oplus x_0,\dots,
x_{n-1}^2 \oplus x_{n-1})$. Let $f\in\BF_n$. Then there exists a unique set
of $a_I\in\gftwo$, $I\in2^{\{0,\dots,n-1\}}$, such that
\begin{equation}\label{eqn:ANF}
  f(x)=\sum_{I\in2^{\{0,\dots,n-1\}}}a_I\bigg(\prod_{i\in I}x_i\bigg)
\end{equation}
\end{theorem}

\begin{proof}
  \begin{align*}
  \lvert\BF_n\rvert
    &= \lvert \gftwo^{2^n} \rvert \\
    &= \lvert \{(a_{\emptyset},\ldots,a_I,\ldots):a_I\in\gftwo\} \rvert \\
    &= \lvert \gftwo[x_0,\dots,x_{n-1}]/ (x_0^2\oplus x_0,\dots,
    x_{n-1}^2 \oplus x_{n-1})\rvert
  \end{align*}
  Because every Boolean function is determined by at least one polynomial
  and the size of the polynomial ring equals the size of the set of all
  Boolean functions, each Boolean function must be uniquely determined by a
  polynomial in the polynomial ring.
\end{proof}

\subsection{The Walsh Transform}
\par The Walsh transform measures the non-linearity of a Boolean function by
determining the distance between a given Boolean function $f(x)$ and a linear
function $\lambda\cdot x$. The Walsh transform is similar to the discrete
Fourier transform and is in fact used to obtain the Fourier coefficients for a
Boolean function. For this paper, the Walsh transform is considered over the
discrete Fourier transform because this is the transformation used by Rothaus
in his original definition of bent functions published in the Journal of
Combinatorial Theory in 1976 \cite{art:r76}. The definitions in this section
follow \cite{bk:lsy11}.

\begin{definition}
  A {\em character} $\Chi$ of a finite abelian group $G$ is a group
  homomorphism from $G$ into the multiplicative group of complex numbers.
\end{definition}

For the purposes of this paper, it should be clear that
$\Chi_\lambda(x):=(-1)^{\lambda\cdot x}$ where $\lambda,x\in\gftwo^n$ is a
{\em group\ character} of $\gftwo^n$. Define the {\em dual\ group}
$\hat{\gftwo^n}$ to be the group of all characters of $\gftwo^n$. The group
operation
in $\hat{\gftwo^n}$ is pointwise multiplication of functions:
\[
(\Chi\cdot\psi)(x)=\Chi(x)\psi(x),\ x\in\gftwo^n.
\]
This operation is closed under multiplication.

\begin{lemma}\label{lem:dual}
  $\gftwo^n\cong\hat{\gftwo^n}$
\end{lemma}

\begin{proof}
  \par Let $\Upsilon:\gftwo^n\rightarrow\hat{\gftwo^n}$ where
  $\Upsilon(\lambda):=\Chi_\lambda$.
  Every character in $\hat{\gftwo^n}$ corresponds to an element of
  $\gftwo^n$. Thus, $\lvert\gftwo^n\rvert=\lvert\hat{\gftwo^n}\rvert$.
  Therefore if $\Upsilon$ is one-to-one, then it must be an isomorphism.\\
  Let $\Upsilon(\lambda_1)=\Upsilon(\lambda_2)$. Then for all $x$
  \begin{align*}
    (-1)^{\lambda_1\cdot x}
      &=(-1)^{\lambda_2\cdot x}\\
      &=(-1)^{(\lambda_1+\lambda_1+\lambda_2)\cdot x}\\
      &=(-1)^{\lambda_1\cdot x}(-1)^{(\lambda_1+\lambda_2)\cdot x}.
  \end{align*}
  Finally, $(\lambda_1+\lambda_2)\cdot x=0$ for all $x\in\gftwo^n$, which
  implies $\lambda_1+\lambda_2=0$. Therefore, $\lambda_1=\lambda_2$.
\end{proof}

\par Addition in $\gftwo^n$ corresponds to multiplication in
$\hat{\gftwo^n}$. By definition
\[
(\Chi_{\lambda_1}\cdot\Chi_{\lambda_2})(x)
  =\Chi_{\lambda_1}(x)\Chi_{\lambda_2}(x)
  =(-1)^{\lambda_1\cdot x}(-1)^{\lambda_2\cdot x}
  =(-1)^{(\lambda_1+\lambda_2)\cdot x}
  =\Chi_{\lambda_1+\lambda_2}(x).
\]

\par It is clear from the proof of Lemma \ref{lem:dual} that all the characters
of $\gftwo^n$ correspond to all of the linear functions in $\BF_n$.

\begin{definition}\label{def:pBF}
  Let $f\in\BF_n$. Then $\hat{f}:\gftwo^n\rightarrow\rrr$ such that
  $\hat{f}(x)=(-1)^{f(x)}$ is a \textit{pseudo-Boolean function}. The set of all
  pseudo Boolean functions is denoted $\hat{\BF}_n=\{\hat{f}:f\in\BF_n\}$.
\end{definition}
\begin{lemma}\label{lem:characters}
\par Every character $\Chi_\lambda$ belongs to $\hat{\BF_n}$.
\end{lemma}
\begin{proof}
  \par This is trivially true.
\end{proof}
\begin{lemma}
  If \[W={\rm span}_\rrr(\hat{\BF}_n)=\left\{\sum_{i\in I}a_i\hat{f}_i:
  \hat{f}_i\in\hat{\BF}_n{\rm ,\ }a_i\in\rrr{\rm ,\ and\ }|I|<\infty\right\},\]
  then the $\hat{\gftwo^n}$ forms an orthonormal basis of $W$.
\end{lemma}
\begin{proof}
  The atomic Boolean functions correspond to a basis of $W$. Thus, the dimension
  of $\hat{\BF_n}$ is at most $2^n$. The $2^n$ characters of $\gftwo^n$
  are elements of $\hat{\BF}_n$, by Lemma \ref{lem:characters}.
  \begin{align*}
    \sum_{x\in\gftwo^n}{\Chi_{\lambda_i}(x)\cdot\Chi_{\lambda_j}(x)}
    &=\sum_{x\in\gftwo^n}
      {(-1)^{(\lambda_i+\lambda_j)\cdot x}}\\
    &=\begin{cases}
      0 & \text{if } i\not=j \\
      2^n & \text{if } i=j.
    \end{cases}
  \end{align*}
  Therefore, the characters of $\gftwo^n$ are orthonormal in $W$. Since the
  dimension of $W$ is at most $2^n$, and there are $2^n$ characters,
  $\hat{\gftwo^n}$ forms an orthonormal basis of $W$.
\end{proof}

%\begin{definition}\label{def:DFT}
% The {\em discrete\ Fourier\ transform} or DFT of a Boolean function is
%  defined by
% \begin{equation}\label{eqn:DFT}
%    \mathcal{F}f(\lambda)
%      =\sum_{x\in\gftwo^n}f(x)\Chi_\lambda(x)
% \end{equation}
%\end{definition}

\begin{definition}\label{def:walsh}
  Let $f\in\BF_n$ and $\lambda\in\gftwo^n$. Then the {\em Walsh transform}
  of $f$ is defined by:
  \begin{equation}\label{eqn:walsh}
    \mathcal{W}_f(\lambda)=\sum_{x\in\gftwo^n}\hat{f}(x)\Chi_\lambda(x).
  \end{equation}
  Let
  \[
    \mathcal{W}(f)=(\mathcal{W}_f(\lambda_0),\dots,\mathcal{W}_f(\lambda_{2^n-1})),
  \]
  where $\lambda_i=B^{-1}(i)$, be the {\it Walsh spectrum} of $f$.
\end{definition}

\begin{example}
\par Here are some examples of the Walsh spectrums of different Boolean
functions:
  \begin{lstlisting}
    sage: f0=BooleanFunction([0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1])
    sage: f0.walsh_hadamard_transform()
    (-2, 6, -6, -6, -2, -2, 2, -6, 2, 2, 6, -2, 2, -6, -2, -2)
    sage: f0.algebraic_normal_form( )
    x0*x1*x2*x3 + x0*x1*x3 + x0*x3 + x0 + x1*x2*x3 + x1*x2 + x1 + x2*x3 + x2
    sage:
    sage: f1=BooleanFunction([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0])
    sage: f1.walsh_hadamard_transform()
    (0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    sage: f1.algebraic_normal_form()
    x0 + 1
    sage:
    sage: f2=BooleanFunction([1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1])
    sage: f2.walsh_hadamard_transform()
    (0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    sage: f2.algebraic_normal_form()
    x0 + x1 + 1
    sage:
    sage: f3=BooleanFunction([1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1])
    sage: f3.walsh_hadamard_transform()
    (2, 2, -2, 14, -2, -2, 2, 2, -2, -2, 2, 2, 2, 2, -2, -2)
    sage: f3.algebraic_normal_form( )
    x0*x1*x2*x3 + x0 + x1*x2*x3 + x1 + 1
  \end{lstlisting}
\end{example}

\par 
\par Every pseudo-Boolean function can be written as a linear combination of
the characters of $\gftwo^n$. The coefficients in these linear combinations
reveal important properties of the functions. Rothaus rewrote the
pseudo-Boolean function as a linear combination of characters
as follows \cite{art:r76}. 

\begin{lemma}
  For $\hat{f}\in\hat{\BF}_n$,
\begin{equation}\label{eqn:rewrite-pseudo}
  \hat{f}(x)
    =\frac{1}{2^{n/2}}
      \sum_{\lambda\in\gftwo^n}c(\lambda)\Chi_\lambda(x)
\end{equation}
  where $c(\lambda)$ are given by
  \begin{equation}\label{eqn:clambda}
    c(\lambda)=\frac{1}{2^{n/2}}\mathcal{W}_f(\lambda)
    %\mathcal{F}\hat{f}(\lambda).
    %=\frac{1}{2^{n/2}}\sum_{x\in\gftwo^n}(-1)^{f(x)+\lambda\cdot x}.
  \end{equation}
\end{lemma}

\par Each $c(\lambda)$ is called a \textit{Fourier coefficient} of $f$.
As observed by Rothaus in \cite{art:r76}, $2^{n/2}c(\lambda)$ is the
number of zeros minus the number of ones of the function
$f(x)+\lambda\cdot x$. The Hamming weight of $f$ is easily determined using
the zero Fourier coefficient $c(0)$:
\begin{align*}
  c(0)&=\frac{1}{2^{n/2}}\sum_{x\in\gftwo^n}(-1)^{f(x)}\\
  &=\frac{1}{2^{n/2}}\big((2^n-{\rm wt}(f))-{\rm wt}(f)\big)
\end{align*}
\begin{equation}
  \Rightarrow {\rm wt}(f)=2^{n-1}-2^{n/2-1}c(0).
\end{equation}

\begin{example}
  There are two cases that should be clear to the reader.
  \begin{enumerate}[1.]
    \item Let $f(x)=\lambda\cdot x$. Then $\mathcal{W}_f(\lambda)=2^n$.
    \item Let $f(x)\not=\lambda\cdot x \ \ \forall x$. Then $f(x)=
      \lambda\cdot x+1 \ \ \forall x$. So, $\mathcal{W}_f(\lambda)=-2^n$
  \end{enumerate}
  In both cases, $f$ is an affine function.
\end{example}

\par For large $|\mathcal{W}_f(\lambda)|$, the Hamming distance between $f$ and
an affine function in $\BF_n$ is small.

\subsection{Bent Functions}
\par These functions are useful in cryptographic applications because they
add resistance to differential attacks as a result of being ``perfectly
non-linear''. As mentioned before, these were defined by Rothaus in 1976. The main
result in Section \ref{sec:boolean-sequences} is given on bent functions because
of their important cryptographic property of being as far away as possible from
every affine function in $\BF_n$.

\begin{definition}
  If all of the Fourier coefficients of $\hat{f}$ are $\pm1$ then
  $f$ is a \textit{bent function}.
\end{definition}

\begin{proposition}{\rm \cite{art:r76}}
  If $f$ is a bent function on $\gftwo^n$, then $n$ is even, $n=2k$.
  Moreover,
  the degree of $f$ is at most $k$, except in the case $k=1$.
\end{proposition}
\begin{proof}
  \par $c(\lambda)=\pm1$. This implies $2^{n/2}c(\lambda)$ is an
  integer. Therefore $n$ must be even.
  \par Let $n=2k$ with $k>1$, and let $r>k$. Consider the polynomial
  $f(x,\allowbreak 0,0,\dots,0)=\allowbreak g(x)$ where $x=(x_1,x_2,\dots,x_r)$
  (up to this point all indexing has
  started at 0; it is more convenient in this proof to begin numbering at
  1). Then by Equation~(\ref{eqn:rewrite-pseudo}),
  \[
  \hat{g}(x)=\frac{1}{2^{r/2}}\sum_{\lambda_1,\lambda_2,\dots,\lambda_r=0,1}
    b(\lambda_1,\dots,\lambda_r)\Chi_{(\lambda_1,\ldots,\lambda_r)}(x)
  \]
  and
  \[
  \hat{f}(x,0)=\frac{1}{2^{n/2}}
    \sum_{\lambda_1,\lambda_2,\dots,\lambda_n=0,1}
    c(\lambda_1,\dots,\lambda_n)\Chi_{(\lambda_1,\ldots,\lambda_n)}(x,0).
  \]
  Because $f(x,0)=g(x)$ and the uniqueness of the Fourier expansion, $b$ and
  $c$ are related such that
  \[
  b(\lambda_1,\dots,\lambda_r)
    =\frac{1}{2^{(n-r)/2}}\sum_{\lambda_{r+1},\dots,\lambda_n=0,1}
    c(\lambda_1,\dots,\lambda_r,\lambda_{r+1},\dots,\lambda_n).
  \]
  \par Then,
  \begin{align*}
  {\rm wt}(f(x,0))&={\rm wt}(g(x))\\
    &=2^{r-1}-2^{r/2-1}b(0)\\
    &=2^{r-1}-2^{r-n/2-1}\sum_{\lambda_{r+1},\dots,\lambda_n=0,1}
      c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n).
  \end{align*}
  \par There are $2^{n-r}$ summands in
  $\sum{c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n)}.$ Since $f$ is bent,
  $c(\lambda)=\pm1$. By rewriting $1=-1+2$,
  \begin{align*}
    \sum{c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n)}
      &=-2^{n-r}+2{\rm wt}(c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n))\\
      &=2\big({\rm wt}(c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n))-2^{n-r-1}\big)
  \end{align*}
  \par Thus, ${\rm wt}(g(x))$ is even. This implies that $g(x)$ is the sum of an
  even number of atomic Boolean functions. Therefore the coefficient of
  $x_1x_2\cdots x_r$ in the polynomial representing $g(x)$ must be 0. This
  is true for every $r>k$, so the degree of $f$ must not be greater than
  $k$.
\end{proof}

% Strict Avalanche Criterion
% directional derivatives
% equivalent definition of a bent function

\par The set of all bent functions is not known. There however are a few basic
constructions which are known. The Rothaus construction and Maiorana-McFarland class of Boolean
functions are presented here as two of the known constructions for bent
functions.

\subsubsection{Rothaus Construction of Bent Functions}
\par In one of the first papers written about bent functions, Rothaus identified
two large general classes of bent function on $\BF_n$, $n=2k$. The simpler of
the two is presented here:
\begin{proposition}
  Let $n$ be even, $x_1,y_1,\dots,x_k,y_k$ be independent variables, and
  $P(x)\in\BF_{n/2}$ (so $P(x)$ is a function $n/2$ variables). Then the polynomial
  $Q(x,y)\in\BF_{n}$ given by
  \begin{equation}
    Q(x,y)=x_1y_1+x_2y_2+\cdots+x_ky_k+P(x)
  \end{equation}
  is bent.
\end{proposition}
\par The proof that this function is bent can be found in Rothaus' paper
\cite{art:r76}.

\begin{example}
  \par Both $f$ and $g$ in this example are bent according to Rothaus.
  \begin{lstlisting}
    sage: B=BooleanPolynomialRing(6,'x')
    sage: B.inject_variables(verbose=false)
    sage: f=BooleanFunction(x0*x1+x2*x3+x4*x5)
    sage: f.truth_table(format='int')
    (0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
    0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1,
    1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1)
    sage: f.is_bent()
    True
    sage: g=f+BooleanFunction(x0*x2+x0)
    sage: g.truth_table(format='int')
    (0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
    0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1,
    1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1)
    sage: g.is_bent()
    True
  \end{lstlisting}
\end{example}
\subsubsection{Maiorana-McFarland Class Construction of Bent Functions}
\par The Maiorana-McFarland class (or M-M class) of Boolean functions is a
generalized Rothaus construction of bent functions. It uses a
permutation function $\pi$ on half of the input variables to each function.

\begin{definition}
  Let $\pi:\gftwo^k\rightarrow\gftwo^k$ be the linear transformation on
  $\gftwo^n$ represented by the matrix $\pi\in M_{k\times k}(\gftwo)$ such that the
  matrix $\pi$ has exactly $k$ non-zero entries arranged so that every row
  and column has exactly one non-zero entry. Then $\pi$ is a
  {\it permutation matrix}.
\end{definition}

\begin{example}
  \ 
  \begin{lstlisting}
    sage: pi0=matrix(GF(2),[[0,0,1],[1,0,0],[0,1,0]])
    sage: pi0
    [0 0 1]
    [1 0 0]
    [0 1 0]
    sage: V=GF(2)^3
    sage: x=V([0,1,1]); y=V([1,0,0])
    sage: (matrix(x)).transpose()
    [0]
    [1]
    [1]
    sage: pi0*(matrix(x)).transpose()
    [1]
    [0]
    [1]
    sage: (matrix(y)).transpose(
    [1]
    [0]
    [0]
    sage: pi0*(matrix(y)).transpose( )
    [0]
    [1]
    [0]
  \end{lstlisting}
\end{example}

\par For every permutation function $\pi$ on $\gftwo^k$ the {\it component permutation
function} $\bar{\pi}$ can defined such that for $0 \leq i \leq k-1$,
\[
\bar{\pi}(i)=j \text{ where } \pi(e_i)=e_j \text{ for basis vectors } e_i,
e_j\in\gftwo^k.
\]

\begin{example}
  If $\pi_0=\begin{bmatrix}
               0&0&1\\
               1&0&0\\
               0&1&0\\
             \end{bmatrix}$ and $\pi_1=
             \begin{bmatrix}
               0&1&0\\
               1&0&0\\
               0&0&1\\
             \end{bmatrix}$, then $\bar{\pi}_0$ is the permutation cycle $(0\,1\,2)$
             and $\bar{\pi}_1$ is the permutation cycle $(0\,1)(2)$.
\end{example}
\par A simple bent function construction is accomplished by using permutations
like the ones defined here. These Boolean functions belong to the {\it
Maiorana-McFarland original class}. This is the set
$\mathcal{M}$ which contains all Boolean functions on
$\gftwo^n=\{(x,y)=(x_0,\dots,x_{n-1},y_0,\dots,y_{n-1}):x,y\in\gftwo^{n/2}\}$, of the form
  \[
  f(x,y)=x\cdot\pi(y)\oplus g(y)
  \]
where $\pi$ is any permutation on $\gftwo^{n/2}$ and $g$ is any Boolean
function on $\gftwo^{n/2}$.

\begin{proposition}{\rm\cite{col:c06}}
\par All functions in the Maiorana-McFarland class of Boolean functions are
bent.
\end{proposition}
\par The proof of these functions being bent can be found in \cite{col:c06}.


\begin{example}
  \par Both $f$ and $g$ in this example are in the Maiorana-McFarland class of
  Boolean functions.
  \begin{lstlisting}
    sage: f=BooleanFunction(x0*x4+x1*x3+x2*x5)
    sage: f.truth_table(format='int')
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
    1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1)
    sage: f.is_bent()
    True
    sage: g=f+BooleanFunction(x0*x2+x0)
    sage: g.is_bent()
    True
  \end{lstlisting}
\end{example}

\section{$N$-adic Integers}\label{sec:n-adic-ring}
\par This section introduces the $N$-adic integer ring and defines the
{\em 2-adic valuation} which is critical to the main result of the paper. The
2-adic integers are very closely connected with the binary sequences generated
by FCSRs which are discussed in Section \ref{sec:shift-registers}.

\subsection{$N$-adic Integer Ring}
\par The notation used in the definition of the $N$-adic numbers will follow
the same notation used by Borevich and Shafarevich in Chapter 1 of
{\em Number Theory} \cite{bk:bs66}. In this section, the set of $N$-adic
integers is shown to be a commutative ring with an identity.
  
\begin{definition}
\label{def:N-adic}
  Let $N$ be an integer. Then the infinite integer sequence $\xn$
  determines an {\em $N$-adic integer} $\alpha$, or
  $\xn \rightarrow \alpha$, if
  \begin{equation} \label{eq:seq}
  x_{i+1} \equiv x_i\pmod{N^{i+1}} \ \ \ \forall i \geq 0.
  \end{equation}
  Two sequences $\xn$ and $(x_n')$ determine the same $N$-adic integer if 
\begin{equation} \label{eq:equiv}
  x_i \equiv x_i' \pmod{N^{i+1}}\ \ \ \forall i \geq 0.
\end{equation}
  The {\em set of all $N$-adic integers} will be denoted by $\zzzn$.
\end{definition}

\par Each integer $x$ is associated with a $N$-adic integer, determined
by the sequence ($x,\ x, \ \dots, \ x,\ \dots$). These integers will be
called {\em rational integers} in the $N$-adic integers.
  
\begin{example} \label{ex:equiv-seq}
  Let $\xn \rightarrow \alpha \in \zzz_3$. Then the first 5 terms of
  $\xn$ may look something like:
  \begin{align*}
    \xn = (&\ 1\ , \ 1+2\cdot3 \ , \ 1+2\cdot3+1\cdot3^2 \ ,\\
            &1+2\cdot3+1\cdot3^2 \ , \ 1+2\cdot3+1\cdot3^2+1\cdot3^4 \ ,
              \ \dots)\\
        = (&1,7,16,16,97,\dots)
  \end{align*}
  Then equivalent sequences to $\xn$ could begin differently for the first
  few terms:
  \begin{align*}
    \yn &= (4,25,16,178,583,\dots) \\
    \zn &= (-2,-47,232,-308,97,\dots)
  \end{align*}
  The sequences for $\yn$ and $\zn$ satisfy equation (\ref{eq:seq}) for the
  first 5 terms, so they could be $N$-adic integers up to this point. Also,
  both are equivalent to $\xn$ according to the equivalence defined in
  equation (\ref{eq:equiv}).
  \begin{align*}
    &1 \equiv 4 \equiv 2 \pmod 3 \\
    &7 \equiv 25 \equiv -47 \pmod{3^2} \\
    &16 \equiv 16 \equiv 232 \pmod{3^3} \\
    &16 \equiv 178 \equiv -308 \pmod{3^4} \\
    &97 \equiv 583 \equiv 97 \pmod{3^5}
  \end{align*}
  Therefore $\xn,\yn,\zn \rightarrow \alpha$.
\end{example}

\par Because there are infinitely many sequence representations for any
$N$-adic integer, it is useful to define a canonical sequence to be used
when writing $N$-adic integers as sequences.
  
\begin{definition}
\label{def:canon}
  \par For a given $N$-adic integer $\alpha$, a given sequence $\an$ with
  the properties:
  \begin{enumerate}[i.]
    \item $\an \rightarrow \alpha$
    \item $\an=(a_0, \ a_0+a_1\cdot N, \ \dots, \ a_0+\dots+a_i\cdot N^i, \ \dots) : 0 \leq a_i < N \ \ \ \forall i \geq 0$
  \end{enumerate}
  will be called {\em canonical}.
  \par The sequence $(a_0,a_1,a_2,\dots,a_i,\dots)$ is the {\em digit
  representation} of $\alpha$. When $N<10$, the digits are usually
  written adjacent to one another. Another equivalent representation of $\alpha$
  is the {\it power series representation} where $\alpha=\sum_{i=0}^\infty
  a_iN^i$ where the $a_i$'s are from the digit representation of $\alpha$.
\end{definition}

\begin{example} \label{ex:canon}
  In Example \ref{ex:equiv-seq}, the sequence $\xn$ was a canonical
  sequence that determined the $N$-adic integer $\alpha$. A few more examples
  of canonical sequences determining 7-adic integers are given here:\\
  \\
 $\beta = 3164\dots = 3+1\cdot7+6\cdot7^2+4\cdot7^3+\cdots$, then the canonical sequence $(b_n) \rightarrow \beta$ is
  \begin{align*}
    (b_n) &= (3, \ 3+1\cdot7, \ 3+1\cdot7+6\cdot7^2, \ 3+1\cdot7+6\cdot7^2+4\cdot7^3, \ \dots)\\
            &= (3,10,304,1676,\dots)
  \end{align*}
  $\gamma = 0164\dots = 0+1\cdot7+6\cdot7^2+4\cdot7^3+\cdots$, then the canonical sequence $(c_n) \rightarrow \gamma$ is
  \begin{align*}
    (c_n) &= (0, \ 1\cdot7, \ 1\cdot7+6\cdot7^2, \ 1\cdot7+6\cdot7^2+4\cdot7^3, \ \dots)\\
            &= (0,7,301,1673,\dots)
  \end{align*}
  $\delta = 5031\dots = 5+0\cdot7+3\cdot7^2+1\cdot7^3+\cdots$, then the canonical sequence $(d_n) \rightarrow \delta$ is
  \begin{align*}
    (d_n) &= (5, \ 5, 5+3\cdot7^2, \ 5+3\cdot7^2+1\cdot7^3, \ \dots)\\
            &= (5,5,152,495,\dots).
  \end{align*}
\end{example}

\begin{definition}
  Addition and multiplication in $\zzzn$ are done term by term. \\
  Let $\alpha,\beta \in \zzzn$ and $\xn \rightarrow \alpha, \yn \rightarrow \beta$. Then,
  \begin{align*}
    \xn+\yn     &:= (x_0+y_0, x_1+y_1, \dots) \rightarrow \alpha+\beta\\
    \xn\cdot\yn &:= (x_0 \cdot y_0, x_1 \cdot y_1, \dots) \rightarrow \alpha \cdot \beta\\ 
  \end{align*}

  Define $(0,0,0,\dots) \rightarrow 0 \in \zzzn$ and $(1,1,1,\dots) \rightarrow 1 \in \zzzn$
\end{definition}

\begin{lemma}\label{lem:identity}
  For $\alpha \in \zzzn$, $\alpha+0=0+\alpha=\alpha$ and $1\cdot\alpha=\alpha\cdot1=\alpha$.
\end{lemma}
\begin{proof}
  Let $\xn\rightarrow\alpha\in\zzzn$.
  \begin{align*}
    \xn+(0,0,\dots)&=(x_0+0,x_1+0,\dots,x_i+0,\dots)\\
                     &=(x_0,\dots,x_i,\dots).\\
    (0,0,\dots)+\xn&=(0+x_0,0+x_1,\dots,0+x_i,\dots)\\
                     &=(x_0,\dots,x_i,\dots).
  \end{align*}
  $\xn=\xn+(0,0,\dots)=(0,0,\dots)+\xn$ implies $\alpha=\alpha+0=0+\alpha$.
  Therefore, the additive identity in $\zzzn$ is 0.

  \begin{align*}
    \xn\cdot(1,1,\dots)&=(x_0\cdot 1,x_1\cdot 1,\dots,x_i\cdot 1,\dots)\\
                         &=(x_0,\dots,x_i,\dots).\\
    (1,1,\dots)\cdot\xn&=(1\cdot x_0,1\cdot x_1,\dots,1\cdot x_i,\dots)\\
                         &=(x_0,\dots,x_i,\dots).
  \end{align*}
   $\xn=\xn\cdot(1,1,\dots)=(1,1,\dots)\cdot\xn$ implies $\alpha=\alpha\cdot1=1\cdot\alpha$.
  Therefore, the multiplicative identity in $\zzzn$ is 1.
\end{proof}   

\par Finally, this section defines a {\em ring} and proves that $\zzzn$ is a
{\em commutative ring with an identity}.
\begin{definition}
\label{def:ring}
  A {\em ring} is a set $R$ with two binary operations defined on it. These are usually
  called addition denoted by +, and multiplication denoted by $\cdot$ or juxtaposition,
  satisfying the following six axioms:
  \begin{enumerate}
    \item Addition is commutative: $a+b=b+a \ \ \forall a,b \in R$.
    \item Addition is associative: $a+(b+c)=(a+b)+c \ \ \forall a,b,c \in R$.
    \item There exists an additive identity, denoted by 0, such that $a+0=a \ \ \forall a \in R$.
    \item $\forall a \in R$ there exists an additive inverse, denoted by $-a$, such
      that $a+(-a)=0$.
    \item Multiplication is associative: $a(bc)=(ab)c \ \forall a,b,c \in R$
    \item Multiplication is left and right distributive over addition:
      \begin{align*}
        a(b+c)&=ab+ac \\
        (b+c)a&=ba+ca
      \end{align*}
  \end{enumerate}
  If it is also true that
  \begin{enumerate}
      \setcounter{enumi}{6}
    \item Multiplication is commutative: $ab=ba \ \ \forall a,b \in R$, then
      $R$ is a {\em commutative ring}.
  \end{enumerate}
  Further if
  \begin{enumerate}
      \setcounter{enumi}{7}
    \item There exists a multiplicative identity denoted by 1 such that
      $a \cdot 1=a$ and $1 \cdot a=a \ \ \forall a \in R$, then $R$ is a
      {\em ring with an identity}.
  \end{enumerate}
  If $R$ satisfies all eight properties, then $R$ is a {\em commutative ring with
  an identity.}
\end{definition}

\begin{theorem}
  $\zzzn$ is a commutative ring with an identity.
\end{theorem}
% p-adic integer ring proof
\begin{proof}
  Let $\xn,\yn,\zn$ determine $\alpha,\beta,\gamma\in\zzzn$ respectively. Then
  \begin{enumerate}
    \item {\em Commutativity of Addition}
      \begin{align*}
            \xn+\yn&=(x_0+y_0,\dots,x_i+y_i,\dots) \\
                   &=(y_0+x_0,\dots,y_i+x_i,\dots) \\
                   &=\yn+\xn.
      \end{align*}
      $\xn+\yn \rightarrow \alpha+\beta$ and $\xn+\yn=\yn+\xn \rightarrow \beta+\alpha$.
      Therefore, by Definition \ref{def:N-adic}, $\alpha+\beta=\beta+\alpha$.
    \item {\em Associativity of Addition}
      \begin{align*}
        \xn+(\yn+\zn)&=\xn+(y_0+z_0,\dots,y_i+z_i,\dots) \\
                     &=(x_0+(y_0+z_0),\dots,x_i+(y_i+z_i),\dots) \\
                     &=((x_0+y_0)+z_0,\dots,(x_i+y_i)+z_i,\dots) \\
                     &=(x_0+y_0,\dots,x_i+y_i,\dots)+\zn \\
                     &=(\xn+\yn)+\zn.
      \end{align*}
      Therefore, $\alpha+(\beta+\gamma)=(\alpha+\beta)+\gamma$.
    \item {\em Existence of the Additive Identity}
      \\ \\
      By Lemma \ref{lem:identity}, $0$ is the additive identity.
    \item {\em Existence of Additive Inverses}
      \\ \\
      Define $-\xn = (N-x_0,N^2-x_1,\dots,N^{i+1}-x_i,\dots) \rightarrow -\alpha$.
      Then
      \begin{align*}
        \xn+(-\xn)&=(x_0+N-x_0,x_1+N^2-x_1,\dots,x_i+N^{i+1}-x_i,\dots) \\
                  &=(N,N^2,\dots,N^{i+1},\dots) \\
                  &\equiv(0,0,\dots) \\
                  &=0.
      \end{align*}
      Therefore, $\alpha+(-\alpha)=0$.
    \item {\em Associativity of Multiplication}
      \begin{align*}
        \xn(\yn\zn)&=\xn(y_0z_0,\dots,y_iz_i,\dots) \\
                   &=(x_0(y_0z_0),\dots,x_i(y_iz_i),\dots) \\
                   &=((x_0y_0)z_0,\dots,(x_iy_i)z_i,\dots) \\
                   &=(x_0y_0,\dots,x_iy_i,\dots)\zn \\
                   &=(\xn\yn)\zn.
      \end{align*}
      Therefore, $\alpha(\beta\gamma)=(\alpha\beta)\gamma$.
    \setcounter{enumi}{6}
    \item {\em Commutativity of Multiplication}
      \begin{align*}
        \xn\yn&=(x_0y_0,\dots,x_iy_i,\dots) \\
              &=(y_0x_0,\dots,y_ix_i,\dots) \\
              &=\yn\xn.
      \end{align*}
      Therefore, $\alpha\beta=\beta\alpha$.
    \setcounter{enumi}{5}
    \item {\em Left and right distributivity of multiplication over addition}
      \begin{align*}
        \xn(\yn+\zn)&=\xn(y_0+z_0,\dots,y_i+z_i,\dots) \\
                    &=(x_0(y_0+z_0),\dots,x_i(y_i+z_i),\dots) \\
                    &=(x_0y_0+x_0z_0,\dots,x_iy_i+x_iz_i,\dots) \\
                    &=\xn\yn+\xn\zn. \\
      \end{align*}
      By commutativity of multiplication,
      \begin{align*}
        (\yn+\zn)\xn&=\xn(\yn+\zn)\\
                    &=\xn\yn+\xn\zn\\
                    &=\yn\xn+\zn\xn.
      \end{align*}
      Therefore, $\alpha(\beta+\gamma)=\alpha\beta+\alpha\gamma$ and
      $(\beta+\gamma)\alpha=\beta\alpha+\gamma\alpha$.
    \setcounter{enumi}{7}
    \item {\em Existence of a multiplicative identity}
      \\ \\
      By Lemma \ref{lem:identity}, 1 is the multiplicative identity.
      \\ \\
      Properties 1 through 8 from Definition~\ref{def:ring} are satisfied,
      so $\zzzn$ is a commutative ring with an identity.
  \end{enumerate}
\end{proof}

\par So that the power series representations of N-adic numbers make sense in
the discussion of FCSRs in Section \ref{sec:shift-registers}, equivalence is
shown between the defined $N$-adic addition and multiplication and the usual
addition and multiplication of power series representations of $N$-adic
integers.

\begin{lemma}
  Addition and multiplication of canonical sequences of $\alpha$ and $\beta$ are
  equivalent to the usual addition and multiplication of the power series
  representations for $\alpha$ and $\beta$.
\end{lemma}
\begin{proof}
  Let ${\bf a}=(a_0,a_0+a_1N,\dots,a_0+a_1N+\cdots+a_kN^k,\dots)$
  and ${\bf b}=(b_0,b_0+b_1N,\dots,b_0+b_1N+\cdots+b_kN^k,\dots)$. And $\alpha$
  and $\beta$ be represented by power series so that
  \[
    \alpha=\sum_{i=0}^\infty a_iN^i{\rm \ and\ } \beta=\sum_{i=0}^\infty b_iN^i.
  \]
  Rewrite ${\bf a}=(\sum_{i=0}^ia_i,\dots,\sum_{i=0}^ka_i2^i,\dots)$ and
  ${\bf b}=(\sum_{i=0}^ib_i,\dots,\sum_{i=0}^kb_i2^i,\dots)$. By the defined
  $N$-adic addition,
  \begin{align*}
    {\bf a}+{\bf b}&=(\sum_{i=0}^0a_i+b_i,\dots,\sum_{i=0}^k(a_i+b_i)2^i,\dots)\\
                &\rightarrow\sum_{i=0}^\infty(a_i+b_i)2^i\\
                &=\sum_{i=0}^\infty a_iN^i + \sum_{i=0}^\infty b_iN^i\\
                &=\alpha+\beta.
  \end{align*}
  Clearly addition is equivalent. By the defined $N$-adic multiplication,
  \begin{align*}
    {\bf a}\cdot{\bf b}
      &=(\sum_{i=0}^0a_i\cdot b_i,\dots,\sum_{i=0}^k\sum_{j=0}^k(a_ib_j)2^{i+j},\dots)\\
      &=(a_0\cdot b_0,\dots,\sum_{i+j\leq k}(a_ib_j)2^{i+j},\dots)\\
      &\rightarrow\sum_{k=0}^\infty\left(\sum_{i+j=k}a_ib_j2^k\right)\\
      &=\left(\sum_{i=0}^\infty a_i2^i\right)\left(\sum_{j=0}^\infty b_j2^j\right)\\
      &=\alpha'\cdot\beta'.
  \end{align*}
  Therfore, multiplication is equivalent as well.
\end{proof}

\begin{theorem}\label{thm:units}
  An $N$-adic integer $\alpha$, which is determined by a sequence $\xn$, is
  a unit if and only if $x_0$ is relatively prime to $N$.
\end{theorem}
\begin{proof}
  Let $\alpha$ be a unit. Then there is an $N$-adic integer $\beta$ such
  that $\alpha\beta=1$. If $\beta$ is determined by the sequence $\yn$, then
  \begin{equation}\label{eq:units}
    x_iy_i\equiv1\pmod{N^{i+1}} \ \ \forall i \geq 0.
  \end{equation}
  In particular, $x_0y_0\equiv1\pmod N$, hence $x_0$ is relatively prime to
  $N$. 
  \par Conversely, let $x_0$ be relatively prime to $N$. Then
  $x_0\not\equiv0\pmod{N}$. From Equation (\ref{eq:seq})
  \begin{align*}
    x_1 &\equiv x_0 \pmod N\\
    &\vdots \\
    x_{i+1} &\equiv x_i \pmod{N^i}. 
  \end{align*}
  Working backward, $x_{i+1} \equiv x_i \equiv \dots \equiv x_1 \equiv
  x_0 \pmod N$. Thus, $x_i$ is relatively prime to $N \ \forall i\geq0$,
  which implies $x_i$ is relatively prime to $N^{i+1}$. Consequently,
  $\forall i\geq0 \ \exists y_i$ such that $x_iy_i \equiv 1 \pmod{N^{i+1}}$.
  Since $x_{i+1} \equiv x_i \pmod N^i$ and $x_{i+1}y_{i+1} \equiv
  x_iy_i \pmod{N^i}$. Then, $y_{i+1} \equiv y_i \pmod{N^i}$. Therefore the
  sequence $\yn$ determines some $N$-adic integer $\beta$. Because
  $x_iy_i \equiv 1 \pmod{N^{i+1}} \ \ \forall i \geq 0$, $\alpha\beta=1$.
  This means $\alpha$ is a unit.
\end{proof}

\par From this theorem it follows that a rational integer $a\in\zzzn$ is a
unit if and only if $a$ is relatively prime to $N$. If $a$ is invertible in
$\zzzn$, then for any rational integer $b\in\zzzn$, $b/a=a^{-1}b\in\zzzn$.

\par For any rational number $b/a$, $a$ relatively prime to $N$, there
exists a sequence $\xn \rightarrow b/a \in \zzzn$. At this point, it is
worth using the digit representation for integers in $\zzzn$. So
$\xn=\{x_0, \ x_0+x_1N, \ \dots, \ x_0+\dots+x_iN^i, \ \dots\}$ and
$b/a = x_0x_1\dots x_i\dots$. Rather than finding $a^{-1}\pmod{N^{i+1}}$ to
determine each $x_i$, it is not too difficult for every $i$ to find
$\sum_{k=0}^ix_kN^k$ such that
\begin{equation}\label{eq:seq-rational}
  b \equiv a\sum_{k=0}^ix_kN^k \pmod{N^{i+1}}.
\end{equation}
Then, 
\begin{equation}
  x_i = \frac{\sum_{k=0}^ix_kN^k - \sum_{k=0}^{i-1}x_kN^k}{N^i}.
\end{equation}

\par Nearly all of the digits for any rational number in $\zzzn$ can also be
found using powers of $N^{-1}$, which is much simpler to analyze than the
brute force search for the digits mentioned above. The following theorem is a
slightly modified version of Theorem 10 in a draft of \cite{bk:gk12} written
by Andrew Klapper and Mark Goresky.

\begin{theorem}\label{thm:10}
  Let $u_0,q,N\in\zzz$, where $q$ is relatively prime to $N$,
  $\lvert u_0 \rvert < q$, and $q=-q_0+\sum_{i=1}^{r}q_iN^i$ for
  $0 \leq q_i < N$. Define $\alpha = u_0/q \in \zzzn$
  such that $\alpha = \sum_{i=0}^{\infty}a_iN^i$ for $0 \leq a_i < N$.
  Also, define $u_k\in\zzz$ such that $u_k/q =
  \sum_{i=k}^{\infty}a_iN^{i-k} \in \zzzn$ and
  $\gamma \equiv N^{-1} \pmod q$. Then, there exist $u_k$ for every $k\geq0$
  such that
  \begin{equation}\label{eq:ak}
    a_k \equiv q^{-1}u_k \pmod N.
  \end{equation}
  If $-q<u_0<0$, then $u_k \in \{-q,\dots,-1\}$ for $k\geq0$.  Otherwise,
  for $k>\lfloor \log_N(q) \rfloor=r$, $u_k \in \{-q,\dots,-1\}$.
  \\ \\
  Let $\omega \in \{-q,\dots,-1\}$ such that $\omega \equiv
  \gamma^k u_0 \pmod q$.  Then for $k>\lfloor \log_N(q) \rfloor=r$, or if
  $-q<u_0<0$, then $k\geq0$,
  \begin{equation}\label{eq:ak-omega}
    a_k \equiv q^{-1}\omega \pmod N.
  \end{equation}
\end{theorem}
\noindent \\ 
\begin{proof}
  Write $u_0/q$ in terms of $u_k$.
  {\allowdisplaybreaks
  \begin{align}
    \frac{u_0}{q} &= a_0 + N\frac{u_1}{q}
                     = a_0 + a_1N + N^2\frac{u_2}{q}
                     = \dots \nonumber \\
                  &= \sum_{i=0}^{k-1}a_iN^i + N^k\frac{u_k}{q} \ \ 
                    \forall k \geq 1. \label{eq:u0/q}
  \end{align}
  }
  Rewrite (\ref{eq:u0/q}) to be
  \begin{equation}\label{eq:u0/q-rw}
    N^ku_k=u_0-q\left(\sum_{i=0}^{k-1}a_iN^i\right) \ \ \forall k \geq 1
  \end{equation}
  Then $\lvert u_0 \rvert < q$ and $0 \leq a_i < p$ from the assumptions and
  equation (\ref{eq:u0/q-rw}). These imply for all $k \geq 1$,
  $\lvert u_0 \rvert = \lvert q\sum_{i=0}^{k-1}a_iN^i + N^ku_k \rvert < q$.
  Then,
  \begin{equation*}
%    -q-q\sum_{i=0}^{k-1}a_iN^i < N^k&u_k < q-q\sum_{i=0}^{k-1}a_iN^i \\
    -q\left(\frac{1+\sum_{i=0}^{k-1}a_iN^i}{N^k}\right)
      < \ u_k
      < q\left(\frac{1-\sum_{i=0}^{k-1}a_iN^i}{N^k}\right).
  \end{equation*}
  $u_k$ may only be greater than zero when $\frac{1-\sum_{i=0}^{k-1}a_iN^i}
  {N^k}$ is greater than zero. This only occurs when the sequence
  $(a_0,\dots,a_j) = (0,\dots,0)$ for $j\geq0$. Such a sequence occurs if
  and only if $u_0\geq0$ and $u_0 \equiv 0 \pmod{N^i}$ for $0\leq i \leq j$,
  $j\geq0$. This is clear from the construction of $N$-adic sequences for
  rational numbers. Therefore $u_k$ may only be greater than zero if
  $u_0\geq0$ and $u_0 \equiv 0 \pmod{N^i}$ for $0\leq i \leq j$, $j\geq0$.
  The lower bound for $u_k$ is greater than $-q$. This is clear because
  $\frac{1+\sum_{i=0}^{k-1}a_iN^i}{N^k}\leq1$.
  Therefore,
  \begin{equation*}
    -q < u_k < 0 {\rm \ \ for \ } -q<u_0<0.
  \end{equation*}
  If $0\leq u_0<q$, then the upper bound remains unchanged.
  \begin{equation*}
    -q < u_k < q\left(\frac{1-\sum_{i=0}^{k-1}a_iN^i}{N^k}\right)
      \ {\rm for} \ 0\leq u_0 < q
  \end{equation*}
  There is still work to be done on the upper bound.
%  {\allowdisplaybreaks
  \begin{align*}
                &0 \leq \sum_{i=0}^{k-1}a_iN^i < N^k \ for \ k\geq1 \\
    \Rightarrow &-q\left(\sum_{i=0}^{k-1}a_iN^i\right) \leq 0 \\
    \Rightarrow \ &u_0-q\left(\sum_{i=0}^{k-1}a_iN^i\right)<q \\
    \Rightarrow \ &N^ku_k<q \\
    \Rightarrow \ &u_k<\frac{q}{N^k}.
  \end{align*}
%  }
  For $k>\lfloor\log_N(q)\rfloor=r$, $\lvert q/N^k \rvert < 1$. Therefore,
  $-q < u_k < 0 \ {\rm for} \ 0\leq u_0 < q \ {\rm and} \ k>r$.
  Further lowering the upperbound, if $u_k=0$, then
  $u_0/q=\sum_{i=0}^{k-1}a_iN^i+0$. This implies $u_0/q$ is a rational
  integer, which is not true. Noting finally that $u_k$ must be an integer.
  If $\lvert u_0 \rvert<q$ and $u_0<0$, or $\lvert u_0 \rvert<q$,
  $u_0\geq0$, and $k>\lfloor \log_N(q) \rfloor=r$, then
  \begin{equation*}
    u_k \in \{-q,\dots,-1\}.
  \end{equation*}
  It has now been shown, for certain restrictions, $u_k$ belongs to a
  specific set of representatives for the residue classes of $\zzz/(q)$.
  Define $\gamma \equiv N^{-1} \pmod q$. Reducing Equation
  (\ref{eq:u0/q-rw}) modulo $q$ shows that
  \begin{equation}
    u_k \equiv \gamma u_{k-1} \pmod q.
  \end{equation}
  Since this is true for all k greater than or equal to 1, it is clear that
  \begin{equation}\label{eq:uk-mod-q}
    u_k \equiv \gamma^ku_0 \pmod q.
  \end{equation}
  Reducing (\ref{eq:u0/q-rw}) modulo $p$ shows that
  \begin{equation}\label{eq:ak-mod-p}
    a_k \equiv q^{-1}u_k \pmod N.
  \end{equation}
  Define $\omega \equiv \gamma^k u_0 \pmod q$, and
  $\rho \equiv q^{-1} \pmod N$.  Finally, if $\lvert u_0 \rvert<q$ and
  $u_0<0$, or $\lvert u_0 \rvert<q$, $u_0\geq0$, and
  $k>\lfloor \log_N(q) \rfloor=r$, then
  \begin{equation}\label{eq:ak-done}
    a_k \equiv \rho\omega \pmod N.
  \end{equation}
\end{proof}
\begin{corollary}\label{cor:aj}
  Let $0\leq u_0 < q$. Define $j$ to be the greatest integer such that
  $u_0 \equiv 0 \pmod{N^j}$. Then the following are true:
  \begin{enumerate}[i.]
%    \item $j\leq\lfloor\log_p{q}\rfloor = r$
    \item $(a_0,\dots,a_{j-1})=(0,\dots,0)$
    \item $u_k>0$ for $k=j$
    \item $u_k \not\equiv 0 \pmod N$
  \end{enumerate}
\end{corollary}

% examples demonstrating the corollary

\par Theorem \ref{thm:10} shows that for $-q<u_0<0$, there is a sequence of
numerators $\{u_k\}$ directly related to the sequence of digits $\{a_k\}$
for $u_0/q\in\zzzn$. The sequence of numerators for a given FCSR with connection
integer $q$ reveals all of the possible strictly periodic states of the
register, each identified by $u_k/q$. This provides an interesting tool for the
analysis of different FCSRs.

% add sage code demonstrating this in the 2-adic case.

\subsection{2-adic Integers}
\par Now the transition is made to discussing the 2-adic integers whose digit
sequences are infinite sequences of 0s and 1s. This brings the discussion closer
the previous sections which dealt with vectors and functions defined on
$\gftwo^n$. The 2-adic integers will act as a bridge between the results on
Boolean functions and the FCSRs which are defined in the next section.

\begin{proposition}{\rm \cite{art:kg97}}\label{prop:rational-periodic}
  There is a one-to-one correspondence between rational numbers
  $\alpha=p/q\in\zzz_2$ (where $q$ is odd) and eventually periodic binary
  sequences ${\bf a}=(a_0,a_1,\dots)$, which associates to each such rational
  number $\alpha$ its digit representation {\bf a}. The sequence ${\bf a}$ is
  strictly periodic if and only if $\alpha\leq 0$ and $|\alpha|<1$.
\end{proposition}
\begin{proof}
  \par Consider the strictly periodic case first. Let ${\bf a}=(a_0,a_1,\dots)$
  be a strictly periodic sequence of period $T$. Set $\alpha={\bf a}$. Computing
  in $\zzz_2$,
  \[
    2^T\alpha=\sum_{i=0}^\infty a_i2^{i+T}
             =\sum_{i=0}^\infty a_{i+T}2^{i+T}
             =\sum_{i=T}^\infty a_i2^i
             =\alpha-\sum_{i=0}^{T-1}a_i2^i.
  \]
  Hence
  \begin{equation}\label{eqn:3}
    \alpha=-\frac{\sum_{i=0}^{T-1}a_i2^i}{2^T-1}
  \end{equation}
  is a negative rational number. Write $\alpha=p/q$ as a fraction reduced to
  lowest terms with $q$ positive. Then $q$ is odd, $p\leq0$, and $|p|<q$.
  \par On the other hand, suppose that $\alpha=p/q$ is given in lowest terms
  with $q$ an odd positive integer, $p\leq0$, and $|p|<q$. Let $T$ be the
  smallest integer such that $2^T\equiv 1 \pmod q$. Such a $T$ exists because
  $q$ is odd. Then $2^T-1$ is divisble by $q$, so set $s=(2^T-1)/q$. Because
  $p=q\sum_{i=0}^\infty a_i2^i$
  \[
    s\cdot(-p)=s(-q\sum_{i=0}^\infty a_i2^i)
              =(1-2^T)(\sum_{i=0}^\infty a_i2^i)
              =\sum_{i=0}^\infty a_i2^i - \sum_{i=T}^\infty a_i2^i
              =\sum_{i=0}^{T-1}a_i2^i
  \]
  Thus $\alpha=s\cdot p/(2^T-1)=-(\sum_{i=0}^{T-1}a_i2^i)/(2^T-1)$. It directly
  follows that $\alpha=2^T\alpha+\sum_{i=0}^{T-1}a_i2^i$, implying that the
  digits sequence ${\bf a}$ of $\alpha$ is strictly periodic.
  \par Now suppose that $\alpha=p/q$ is an arbitrary rational number. Let
  $M=\lceil\alpha\rceil$ be the next largest integer. If $M\geq0$, then its digit
  sequence ends in an infinite string of 0s. If $M<0$, then its digit sequence
  ends in an infinite string of 1s. However, $\alpha=M+p'/q$ where $p'\leq0$ and
  $|p'|<q$, so the digit sequence of $p'/q$ is strictly periodic. It follows
  that the digit sequence ${\bf a}$ of $\alpha=M+p'/q$ must be eventually
  periodic.
  \par On the other hand, an eventually periodic sequence ${\bf
  a}=(a_0,a_1,\dots)$ corresponds to a rational number $\alpha={\bf a}$ because
  it is given by a finite transient term $\sum_{i=0}^{k-1}a_i2^i$ (for some
  nonnegative integer $k$) plus a periodic term, $\sum_{i=k}^\infty
  a_i2^i=2^k\sum_{i=0}^\infty a_{j+k}2^j$, both of which are rational numbers.
\end{proof}



\par The 2-adic valuation is needed for the main result. It is defined here.

\begin{definition}\label{2-adic-val}
  Let $\alpha=\an\in\zzz_2\setminus(0)$. If $m$ is the smallest number in
  $\nnn$ such that $a_m \not\equiv 0 \pmod{2^{m+1}}$, then the {\em 2-adic\ 
  valuation} of $\alpha$ is $m$, or $\log_2(\alpha)=m$. If $\alpha=0$, then
  $\log_2(\alpha)=\infty$.
\end{definition}

\begin{definition}\label{2-adic-norm}
  If $\alpha \in \zzz_2$, then the {\em 2-adic norm} of $\alpha$ is
  $\lVert \alpha \rVert_2 = 2^{-m}$ where $m=\log_2(\alpha)$. 
\end{definition}

\par This paper will be careful not to confuse $\log_2$ in $\zzzn$ with 
$\log_2$ in $\mathbb{R}$.

\begin{example}
  Let $\alpha=00001011011\cdots\in\zzz_2$. Then $\log_2(\alpha)=4$.
\end{example}

\section{Shift Registers}\label{sec:shift-registers}
\par The {\it feedback with carry shift register} (or FCSR) is a type of
shift register used in stream ciphers. Though there exist attacks against
this type of shift register by itself, it is possible to combine FCSRs
together in ways that no known attacks are useful. This however does not
guarantee security because the combining of the FCSRs greatly increases the
complexity of the cryptanalysis on the stream cipher. Despite the security
challenges, the speed of an FCSR implementation is very attractive for
engineers of hardware based cryptosystems.

\par This section will be used as an introduction to finite state machines
and feedback with carry shift registers. The FCSR will be considered in the
binary case and analyzed using $\zzz_2$. This analysis is then extended to
the case when bent sequences which could be generated by FCSRs, which leads to
the main result in Section~\ref{sec:boolean-sequences}.

\subsection{Finite State Machines}
\par It is appropriate to preface the discussion about FCSRs with general finite
state machines. Solomon W. Golomb's book {\em Shift Register Sequences}
\cite{bk:g82}, written in 1967 and revised in 1982, established a definition of
finite state machines and shift registers used in much of the literature today.

\begin{definition}\label{finite-state-machine}
  A {\em finite state machine} consists of a finite collection of {\em states}
  $K$, which sequentially accepts a sequence of {\em inputs} from a finite set
  $A$, and produces a sequence of {\em outputs} from a finite set
  $B$. Moreover, there is an {\em output function} $\mu$ which computes
  the present output as a fixed function of present input and present state,
  and a
  {\em next state function} $\delta$ which computes the next states as a fixed
  function of present input and present state. In a more mathematical manner,
  $\mu$ and $\delta$ are defined such that
  \begin{eqnarray}
    \mu:K \times A \rightarrow B \quad &\mu(k_n,a_n)=b_n \\
    \delta:K \times A \rightarrow K \quad &\delta(k_n,a_n)=k_{n+1}
  \end{eqnarray}
\end{definition}

% insert table example of a finite state machine

\par The most fundamental observation by Golomb is the following proposition.
Its result guarantees the periodicity of any finite state machine with
eventually periodic input.

\begin{proposition}\label{prop:golomb-2}
  If the input sequence to a finite state machine is eventually periodic, then
  the output sequence is eventually periodic.
\end{proposition}
\begin{proof}
  Let $p$ be the period of the inputs once the machine becomes periodic at time
  $t$. Then, for $h>0$ and $c>t$, $a_c=a_{c+hp}$. Since $K$ is finite, there
  must be $r>s>t$ such that, for some $h>0$ such that,
  \[
  k_{r+1}=\delta(k_r,a_r)=\delta(k_s,a_{r+hp})=k_{s+1}.
  \]
  It should also be clear that $a_{r+i}=a_{r+i+hp}$ for $h>0$. So by induction,
  $\forall i>0$
  \[
  k_{r+i+1}=\delta(k_{r+i},a_{r+i})=\delta(k_{s+i},a_{r+i+hp})=k_{s+i+1}
  \]
  Finally, this proves $b_{r+i+1}=b_{s+i+1}$. Thus, the eventual period of this
  machine is $r-s$.
\end{proof}

\par The next object defined is called an $N$-ary $n$-stage machine. It can be
used to represent any finite state machine. It is also a natural generalization
of shift registers, so thinking of finite state machines in the context of
$N$-ary $n$-state machines will make the transition to talking about shift
registers much smoother.

\begin{definition}\label{N-ary-n-stage-machine}
  Choose $n,m,r\in\nnn$. Then define a finite state machine with the
  following sets:
  \begin{enumerate}[1.]
    \item $D=\{0,\dots,N-1\}$. This set contains the {\em $N$-ary digits} of the
      machine.
    \item $K=\{\sum_{i=0}^{n-1}x_iN^i:x_i\in D\}$. This set contains the
      {\em $N$-ary states} of the machine.
    \item $A=\{\sum_{i=0}^{m-1}y_iN^i:y_i\in D\}$. This set contains the
      {\em $N$-ary inputs} of the machine.
    \item $B=\{\sum_{i=0}^{r-1}z_iN^i:z_i\in D\}$. This set contains the
      {\em $N$-ary outputs} of the machine.
    \item $\Delta=\{\delta_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}):0\le i<n\}$ where
      $\delta_i:K\times A\rightarrow D$. This set contains the {\em $N$-ary next state functions} of the machine.
    \item $M=\{\mu_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}):0\le i<r\}$.
      $\mu_i:K\times A\rightarrow D$. This set contains the {\em $N$-ary output functions} of the machine.
  \end{enumerate}
  The next state and output are determined from the current state and input by the
  following equations:
  \begin{eqnarray}
    x_i^*=\delta_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}) \quad 0\le i<n \\
    z_i=\mu_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}) \quad 0\le i<r
  \end{eqnarray}
  This finite state machine is called an {\em $N$-ary $n$-stage machine} and
  will be denoted by $\mathcal{M}(N,n,m,r)$.
\end{definition}

\par By making the state the input to the machine as well, this machine
becomes autonomous in the sense that it no longer needs outside input. Then
each new state and output is based on the previous state of the machine. For
$N=2$, $f_i$ and $g_i$ are Boolean functions on $n+m$ variables.
A binary $n$-stage machine can be defined by $n+r$ Boolean functions each
on $n+m$ variables.

\subsection{Feedback with Carry Shift Registers}

\par In the set of autonomous finite state machines is a type of machine
called a {\it shift register}. The variables making up the state of a shift
register pass their values directly to the next variable in the state until
the value is pushed out of the register as the output. Here, what was referred
as an $n$-stage machine will now be called an $r$-stage machine as $n$ will be
used to index the output sequences of FCSRs.

\begin{definition}\label{def:shift-register}
  Let $\mathcal{M}(2,r,-1,0)$ be an binary $r$-stage machine with no input
  and exactly 1 output value. Also, let $g,f_i\in\BF_n$ where the states
  $(x_0,\dots,x_{r-1})$ are the domain of $g$ and $f_i$, $f_i(x)=x_{i+1}$ for
  $0\leq i \leq n-2$, and $g(x)=x_0$. This type of machine will be denoted
  by $\mathcal{SR}(2,r)$.
\end{definition}

\par When the function $f_{r-1}\in\BF_r$ is linear, then $\mathcal{SR}(2,r)$ is
called a {\it linear feedback shift register}. An LFSR is drawn in Figure
\ref{fig:LFSR}. This is the case where $f_{r-1}=\sum_{i=1}^rq_ix_{r-i}$ where
each $x_i,q_i \in \gftwo$. The $q_i$'s are called {\it taps}. In computer
science terms, to move forward in the sequence of states, each bit in the state
of the register shifts to the right one spot and then the newest bit enters
on the left end of the register and is the value given when each bit from
the previous state is AND'ed with its corresponding tap and then XOR'ed with
all the other AND'ed bit and taps.

\setlength{\unitlength}{1mm}
\begin{figure}[h!]
  \centering
  \begin{picture}(90,40)(-25,-25)
    %% State of the register
    \put(0,0){\framebox(10,10){$x_{n-1}$}}
    \put(10,0){\framebox(10,10){$x_{n-2}$}}
    \put(20,0){\framebox(10,10){$\dots$}}
    \put(30,0){\framebox(10,10){$x_{1}$}}
    \put(40,0){\framebox(10,10){$x_{0}$}}
    \put(50,5){\vector(4,0){10}}
    %% Taps
    \put(0,-13){\makebox(10,10){$q_1$}}
    \put(5,-8.5){\circle{9}}
    \put(10,-13){\makebox(10,10){$q_2$}}
    \put(15,-8.5){\circle{9}}
    \put(20,-13){\makebox(10,10){$\dots$}}
    \put(30,-13){\makebox(10,10){$q_{n-1}$}}
    \put(35,-8.5){\circle{9}}
    \put(40,-13){\makebox(10,10){$q_r$}}
    \put(45,-8.5){\circle{9}}
    %% Lines connecting Taps and the State of the Register
    \multiput(5,-0.2)(10,0){2}{\line(0,-6){4}}
    \multiput(35,-0.2)(10,0){2}{\line(0,-6){4}}
    %% Summer
    \put(-20,-25){\framebox(10,10){\Large $\sum$}}
    %% Lines from Taps to Summer
    \put(5,-12.8){\line(0,-6){3.5}}
    \put(15,-12.8){\line(0,-6){5.5}}
    \put(35,-12.8){\line(0,-6){8.5}}
    \put(45,-12.8){\line(0,-6){10.5}}
    \put(5,-16.3){\vector(-4,0){15}}
    \put(15,-18.3){\vector(-4,0){25}}
    \put(35,-21.3){\vector(-4,0){45}}
    \put(45,-23.3){\vector(-4,0){55}}
    %% Lines from Summer
    \put(-13,-15){\line(0,0){20}}
    \put(-13,5){\vector(4,0){13}}
    %% mod N
    \put(-13,5){\makebox(13,5){mod 2}}
  \end{picture}
  \caption{Linear Feedback Shift Register}
  \label{fig:LFSR}
\end{figure}

\par Linear feedback shift registers are well-studied in \cite{bk:g82}. By
using the Berlekamp-Massey algorithm it is possible to recover the state of
a given LFSR based on the output sequence. In fact given an LFSR output sequence
with period $2^r-1$, the Berlekamp-Massey algorithm will find a unique
minimal-length LFSR which generates this output after the first $2n$ digits have
been processed \cite{art:m69}. This algorithm is studied in more detail in
\cite{art:b06}.

\par In Figure \ref{fig:FCSR}, there is a memory cell attached to the linear
feedback shift register which adds some complexity to the register. In the
modified shift register shown in Figure \ref{fig:FCSR}, in each cycle, the
whole number quotient of $\sum_{i=1}^rq_ix_{r-i}$ is kept in the memory cell
$z$. The memory cell from the previous state of the modified shift register
is used to determined the sum modulo 2 for the newest bit in the state of
the register. A shift register modified in this way is known as a {\it
binary feedback with carry shift register}, or FCSR. For this paper, FCSRs
will only be considered in the binary case. Many of the theorems do
generalize the $N$-ary case, though sometimes it is necessary that $N$ be
prime.

\begin{figure}[h!]
  \centering
  \begin{picture}(90,40)(-40,-25)
    %% State of the register
    \put(0,0){\framebox(10,10){$x_{r-1}$}}
    \put(10,0){\framebox(10,10){$x_{r-2}$}}
    \put(20,0){\framebox(10,10){$\dots$}}
    \put(30,0){\framebox(10,10){$x_{1}$}}
    \put(40,0){\framebox(10,10){$x_{0}$}}
    \put(50,5){\vector(4,0){10}}
    %% Taps
    \put(0,-13){\makebox(10,10){$q_1$}}
    \put(5,-8.5){\circle{9}}
    \put(10,-13){\makebox(10,10){$q_2$}}
    \put(15,-8.5){\circle{9}}
    \put(20,-13){\makebox(10,10){$\dots$}}
    \put(30,-13){\makebox(10,10){$q_{r-1}$}}
    \put(35,-8.5){\circle{9}}
    \put(40,-13){\makebox(10,10){$q_r$}}
    \put(45,-8.5){\circle{9}}
    %% Lines connecting Taps and the State of the Register
    \multiput(5,-0.2)(10,0){2}{\line(0,-6){4}}
    \multiput(35,-0.2)(10,0){2}{\line(0,-6){4}}
    %% Summer
    \put(-20,-25){\framebox(10,10){\Large $\sum$}}
    %% Lines from Taps to Summer
    \put(5,-12.8){\line(0,-6){3.5}}
    \put(15,-12.8){\line(0,-6){5.5}}
    \put(35,-12.8){\line(0,-6){8.5}}
    \put(45,-12.8){\line(0,-6){10.5}}
    \put(5,-16.3){\vector(-4,0){15}}
    \put(15,-18.3){\vector(-4,0){25}}
    \put(35,-21.3){\vector(-4,0){45}}
    \put(45,-23.3){\vector(-4,0){55}}
    %% Lines from Summer
    \put(-13,-15){\line(0,0){20}}
    \put(-13,5){\vector(4,0){13}}
    \put(-17,-15){\line(0,0){20}}
    \put(-17,5){\vector(-4,0){13}}
    %% Memory cell z
    \put(-40,0){\framebox(10,10){$z$}}
    %% Lines from memory cell to summer
    \put(-35,0){\line(0,-6){20}}
    \put(-35,-20){\vector(4,0){15}}
    %% div 2 mod 2
    \put(-13,5){\makebox(13,5){mod $2$}}
    \put(-29.5,5){\makebox(13,5){div $2$}}
  \end{picture}
  \caption{Binary Feedback with Carry Shift Register} 
  \label{fig:FCSR}
\end{figure}

\begin{definition}\label{def:fcsr}
  Let $q_1,\dots,q_r\in{0,1}\subset\zzz$ and $q_0=-1$. A {\em binary feedback with carry shift register} 
  of length $n$ with {\em taps} $q_1,\dots,q_r$ is a modified shift register
  whose states are collections
  \[
  (x_0,x_1,\dots,x_{r-1};z) \text{ where } x_i\in\gftwo \text{ and } z \in \zzz
  \]
  where $z$ is called the {\it memory cell}. The state changes according
  to the following rules:
  \begin{enumerate}[1.]
    \item Compute
      \[
        \sigma_n = \sum^r_{i=1}q_ia_{n-i}+z_{n-1}.
      \]
    \item The output is $x_0$.
    \item Then the new state $(x_0,x_1,\dots,x_{n-1};z)
      =(x_1,\dots,x_{n-1},\sigma_n\pmod2;\sigma_n(\text{div }2))$.
  \end{enumerate}
\end{definition}

\begin{lemma}\label{lem:linear-recur}
\par If the sequence $\alpha=(a_0,a_1,\dots)$ where $a_i\in\{0,1\}$ and
$a_i\equiv x_i\pmod2$, and $\zeta=(z_{n-1},z_n,z_{n+1},\dots)$ where each
$z_i$ is the value of the memory cell for the corresponding $x_i$, then
these two sequences are related by the following linear recurrence
\begin{equation}\label{eqn:lin-rec}
  a_k+2z_k=q_1a_{k-1}+\cdots+q_ra_{k-r}+z_{k-1} \text{ for } k\geq r.
\end{equation}
\end{lemma}

\par Recall from Proposition~\label{prop:golomb-2} that an FCSR must be
eventually periodic. By Proposition~\label{prop:rational-periodic}, the sequence
generated by every FCSR can then be represented by a rational number in
$\zzz_2$. This rational number, or sequence generated, is entirely determined by
the initial state and the taps of the register.

\begin{proposition}{\rm \cite{art:kg97}}\label{prop:FCSR-seq}
  Let $q_1,\dots,q_r$ be the taps, $z_{r-1}$ be the initial memory, and
  $a_{r-1},\dots,a_1,a_0$ be the initial state of an FCSR. Define
  $q=1+\sum_{i=1}^{r}q_i2^i$ and
  \begin{equation*}
    p=\left(\sum_{i=0}^{r-1}\sum_{j=0}^iq_ja_{i-j}2^i\right)-z_{r-1}2^r.
  \end{equation*}
  Then the output sequence ${\bf a}$ of this FCSR is the digit representation of
  the 2-adic integer
  \begin{equation}\label{eqn:alpha}
    \alpha=\sum_{i=0}^\infty a_i2^i=p/q.
  \end{equation}
\end{proposition}
\begin{proof}
  Consider the transition from one state of the FCSR to the next. Suppose that,
  for some given state, the value of the memory is $z_{n-1}$ and that the
  contents of the register is given by the $r$ bits $a_{n-1},\dots,a_{n-r}$.
  The next state of the register is determined by calculating
  \begin{equation*}
    \sigma_n=z_{n-1}+\sum_{i=1}^rq_ia_{n-i},
  \end{equation*}
  writing the new memory contents as $z_n=\sigma_n(\text{div }2)$, and writing
  the new contents of the state $a_n=\sigma_n\pmod2$. As stated in Lemma
  \ref{lem:linear-recur}, these equations may be combined into the expression
  \[
    \sigma_n=2z_n+a_n.
  \]
  It follows that
  \begin{equation}\label{eqn:an}
    a_n=\sum_{i=1}^rq_ia_{n-i}+(z_{n-1}-2z_n),
  \end{equation}
  for $n\geq r$. Now, by substituting Equation~(\ref{eqn:an}) into Equation
  (\ref{eqn:alpha}),
  \begin{align}
    \alpha&=a_0+a_1 2+\cdots+a_{r-1}2^{r-1}+\sum_{n=r}^\infty a_n2^n \notag\\
          &=x+\sum_{n=r}^\infty\left( \sum_{i=1}^r q_ia_{n-i} \right)2^n
          +\sum_{n=r}^\infty (z_{n-1}-2z_n)2^n. \label{eqn:alpha-fcsr}
  \end{align}
  where $x=\sum_{i=0}^{r-1}a_i2^i$ is the integer represented by the initial
  state of the register. The second summation in Equation~(\ref{eqn:alpha-fcsr})
  cancels except for the first term, $z_{r-1}$, leaving
  \begin{align*}
    \alpha&=x+z_{r-1}2^r+\sum_{n=r}^\infty\sum_{i=1}^r q_i2^ia_{n-i}2^{n-i}\\
          &=x+z_{r-1}2^r+\sum_{i=1}^r{q_i2^i}\left(\sum_{n=r}^\infty a_{n-i}2^{n-i}\right)\\
          &=x+z_{r-1}2^r+\sum_{i=1}^r{q_i2^i}(\alpha-(a_02^0+a_12^1+\cdots+a_{r-i-1}2^{r-i-1}))\\
          &=x+z_{r-1}2^r+\alpha\sum_{i=1}^r{q_i2^i}-\sum_{i=1}^{r-1}\sum_{j=0}^{r-i-1}q_i2^ia_j2^j.
  \end{align*}
  (where the inner sum is empty, hence zero, when $i=r$ in the third line).
  These equations give
  \begin{align*}
    \alpha&=\frac{x+z_{r-1}2^r-\sum_{i=1}^{r-1}\sum_{j=0}^{r-i-1}q_i2^ia_j2^j}
                {1-\sum_{i=1}^r q_i2^i}\\
          &=\frac{\sum_{i=0}^{r-1}\sum_{j=0}^{r-i-1}q_i2^ia_j2^j-z_{r-1}2^r}{q}
  \end{align*}
  since $q_0=-1$. The double summation is over all pairs of integers $0\leq i,j
  \leq r-1$ with $i+j\leq r-1$. Setting $k=i+j$ gives
  \begin{equation}\label{eqn:fcsr-seq}
    \alpha=\frac{\left(\sum_{k=0}^{r-1}\sum_{i=0}^kq_ia_{k-i}2^k\right)-z_{r-1}2^r}{q}
          =\frac{p}{q}
  \end{equation}
  as claimed.
\end{proof}

\begin{corollary}
  \par Changing the memory by $b$ changes the value of $\alpha$ by $-b2^r/q$. If
  $\alpha=p/q<0$, then the initial memory $z_{r-1}\geq 0$.
\end{corollary}
\begin{proof}
  \par The first statement follows trivially from Equation~(\ref{eqn:fcsr-seq}).
  \par The second statemtent is not as obvious. If $q<0$, then the numerator
  must be positive for $p/q$ to be negative. Since
  \begin{equation}\label{eqn:memory-v-initial_state}
    z_{r-1}2^r\geq\sum_{k=0}^{r-1}\sum_{i=0}^kq_ia_{k-i}2^k\geq0,
  \end{equation}
  this implies $z_{r-1}=0$. If $q>0$, then the numerator must negative.
  By Equation~(\ref{eqn:memory-v-initial_state}), $z_{r-1}>0$. Therefore,
  $z_{r-1}\geq0$.
\end{proof}

\par It can also be shown that the memory cell of every FCSR is bounded and
eventually lies between 0 and ${\rm wt(q+1)}$, for $q>0$.

\begin{proposition}{\rm \cite{art:kg97}}\label{prop:mem-bound}
  \par Let $w={\rm wt}(q+1)$. If an FCSR is in a periodic state, then the memory
  is in the range $0\leq z<w$. If the initial memory $z_{n-1}\geq w$, then it
  will monotonically decrease and will arrive in the range $0\leq z<w$ within
  $\lfloor\log_2(z_{n-1}-w)\rfloor+r$ steps. If the initial memory $z_{n-1}<0$,
  then it will monotonically increase and will arrive in the range $0\leq z<w$
  within $\lceil\log_2(|z_{n-1}|)\rceil+r$ steps. (The logarithm functions in
  this proposition will be real-valued.)
\end{proposition}
\begin{proof}
  \par First, observe that if the initial memory value $z_{n-1}$ lies in the
  range $0\leq z_{n-1}<w$, then the same will be true for all later values of
  the memory. This follows from Definition~\ref{def:fcsr} because
  $\sigma_n = \sum^r_{i=1}q_ia_{n-i}+z_{n-1} \leq w+z_{n-1} < 2w$. So
  $z_n=\lfloor\sigma_n/2\rfloor<w$.
  \par By the same argument, if the initial memory value is $z_{n-1}=w$, then
  the later values of memory will be no greater than $w$; but in this case,
  within $r$ steps, the memory will drop below $w$ (and will remain so
  thereafter) for the following reason. If the memory does not decrease (i.e.
  $z_n=w$), then this means that a 1 appeared at {\it all} the tapped cells,
  that $\sigma_n=2w$, and that $x_n=\sigma_n\pmod2=0$ was fed into the register.
  The value of $\sigma$ will fall below $2w$ when this 0 reaches the first
  tapped cell (if not before), at which time we will have
  $z=\lfloor\sigma/2\rfloor<w$.
  \par Moreover, if we initialize an FCSR with a larger memory value,
  $z_{n-1}>w$, then with each step, the excess $e_{n-1}=z_{n-1}-w$ will become
  reduced by a factor of 1/2, that is $e_n\leq\lfloor e_{n-1}/2\rfloor$. So
  after $\lfloor\log_2(z_{n-1}-w)\rfloor+1$ steps, the memory will be no more
  than $w$. This follows from Definition~\ref{def:fcsr} which gives
  \[
    e_n=z_n-w=\left\lfloor\frac{\sigma_n}{2}\right\rfloor-w
    \leq\left\lfloor\frac{w+w+e_{n-1}}{2}\right\rfloor-w
    =\left\lfloor\frac{e_{n-1}}{2}\right\rfloor.
  \]
  Now consider the case of negative initial memory, $z_{n-1}<0$. By Definition
  \ref{def:fcsr}, it is possible that $\sigma_n\geq0$, in which case the next
  memory value will be $z_n\geq0$ (where it will remain thereafter). So suppose
  that $\sigma_n<0$. Then, again by Definition~\ref{def:fcsr},
  \[
    |z_n|\leq\frac{|\sigma_n|+1}{2}\leq\frac{|z_{n-1}|+1}{2}.
  \]
  Iterating this formula, it is easy to see that after
  $K=\lceil\log_2(|z_{n-1}|)\rceil$ steps, either the memory $z$ has become
  nonnegative, or else
  \[
    |z|\leq\frac{z_{n-1}}{2^K}+\frac{1}{2^K}+\frac{1}{2^{K-1}}+\cdots+\frac{1}{2}<2
  \],
  in which case the memory must be $m=-1$. There is a single situation in which
  the memory can remain at $-1$ forever: if there are no feedback taps on the
  shift register (so $q=-1$). In this case, the memory will feed 1s into the
  shift register forever. However, we assumed that $q>0$ to rule out this
  possibility. If $q>0$, then as soon as a nonzero feedback occurs, the memory
  will become nonnegative, where it will remain thereafter.
\end{proof}

\par Prosition \ref{prop:mem-bound} shows that eventually every FCSR reaches
a point where there are a
finite number of inputs from the memory cells and of states. This means that
every FCSR eventually satisfies the definition of a finite state machine. As a
result, the output of every FCSR is eventually periodic. In Section
\ref{sec:n-adic-ring}, it was shown than every eventually periodic sequence of
0s and 1s corresponds to an $\alpha=p/q\in\zzz_2$. This fact makes FCSRs
extremely vulnerable to rational approximation algorithms.

\subsection{FCSR Synthesis}
\par The problem of synthesis lies in the following question: Given an eventually
periodic sequence of 0s and 1s generated by an FCSR, can you find $a$ and $b$
such that sequence generated is equivalent to digit representation of
$\frac{a}{b}\in\zzz_2$. If there are no constraints on $a$ and $b$, then 
at least a period of the sequence must be known to solve the problem. However,
every FCSR is limited to a certain number of $p/q\in\zzz_2$ that it can generate
become of memory restrictions. The rational approximation algorithm shown in this paper
uses the fact that only so many possibilities exist for a given FCSR to show
that it will eventually reach the correct approximation in a finite number of
steps.  As a quick example of this, consider the FCSR in Figure
\ref{fig:FCSR-4over5}. By Proposition~\ref{prop:FCSR-seq}, it should be clear
that the initial states, taps, and memory completely determine the 2-adic integer
represented by the sequence generated. Both the initial states and taps are
finite, and the memory is bounded at the initial stage of the register.

\begin{figure}[h!]\label{fig:FCSR-4over5}
  \setlength{\unitlength}{1mm}
  \centering
  \begin{picture}(90,40)(-40,-25)
    %% State of the register
    \put(0,0){\framebox(10,10){1}}
    \put(10,0){\framebox(10,10){1}}
    \put(20,0){\framebox(10,10){$0$}}
    \put(30,0){\framebox(10,10){$0$}}
    \put(40,5){\vector(4,0){10}}
    %% Taps
    \put(0,-13){\makebox(10,10){1}}
    \put(5,-8.5){\circle{9}}
    \put(10,-13){\makebox(10,10){1}}
    \put(15,-8.5){\circle{9}}
    \put(20,-13){\makebox(10,10){0}}
    \put(25,-8.5){\circle{9}}
    \put(30,-13){\makebox(10,10){0}}
    \put(35,-8.5){\circle{9}}
    %% Lines connecting Taps and the State of the Register
    \multiput(5,-0.2)(10,0){4}{\line(0,-6){4}}
    %% Summer
    \put(-20,-25){\framebox(10,10){\Large $\sum$}}
    %% Lines from Taps to Summer
    \put(5,-12.8){\line(0,-6){3.5}}
    \put(15,-12.8){\line(0,-6){5.5}}
    \put(25,-12.8){\line(0,-6){8.5}}
    \put(35,-12.8){\line(0,-6){10.5}}
    \put(5,-16.3){\vector(-4,0){15}}
    \put(15,-18.3){\vector(-4,0){25}}
    \put(25,-21.3){\vector(-4,0){35}}
    \put(35,-23.3){\vector(-4,0){45}}
    %% Lines from Summer
    \put(-13,-15){\line(0,0){20}}
    \put(-13,5){\vector(4,0){13}}
    \put(-17,-15){\line(0,0){20}}
    \put(-17,5){\vector(-4,0){13}}
    %% Memory cell z
    \put(-40,0){\framebox(10,10){0}}
    %% Lines from memory cell to summer
    \put(-35,0){\line(0,-6){20}}
    \put(-35,-20){\vector(4,0){15}}
    %% div 2 mod 2
    \put(-13,5){\makebox(13,5){mod $2$}}
    \put(-29.5,5){\makebox(13,5){div $2$}}
  \end{picture}
  \caption{FCSR which generate the sequence
    $\frac{-4}{5}=00110011001100110011\cdots$}
\end{figure}

\par The FCSR in Figure~\ref{fig:FCSR-4over5} is meant as a simple visualization
how after fooling with all of the possible initial states and tap arrangements,
the size of the memory becomes the only means to create new possibilities in the
sequence generated. 

\subsection{Xu's Rational Approximation Algorithm}
\par It turns out that given a sequence generated by an FCSR it is easy to
reproduce to FCSR from which it came from. This is why using FCSRs by themselves
do not generate secure stream ciphers. If used as a stream cipher, the key for
the FCSR would be the taps and the initial state. All an attacker would need is
a relatively short piece of the output sequence to reveal every part of the key.
This ciphertext only attack is a complete break of the stream cipher. In fact, any
arrangement of taps and initial state of an FCSR can be revealed very quickly.
\par In Goresky and Klapper's book \cite{bk:gk12}, they describe in pseudocode Xu's rational
approximation algorithm for $\pi$-adic sequences in any ring $R$. A
demonstration of Xu's algorithm is presented here in the context of the ring
$\zzz_2$. The algorithm takes as input the first $n$ terms
of an $N$-adic sequence ${\bf a}=(a_0,a_1,\dots)$ associated to a rational
number $\alpha=p/q\in\zzz_2$ and outputs a rational number $\alpha_n=p'/q'$
whose first $n$ terms match
{\bf a}. Running Xu's algorithm for small $n$ can sometimes result in $\alpha_n$
which are far from $\alpha$, but in the examples below, it is easy to see that as
$n$ grows large, Xu's algorithm eventually reaches the correct $\alpha$. In
fact, for large enough $n$, Xu's algorithm will reach the correct $\alpha$.

\begin{example}
  This example uses the function {\ttfamily rational\_synthesis\_xu}
  from the {\ttfamily Sage} script {\ttfamily afsr.sage}. The source code for
  this function can be download from
  \url{https://github.com/celerier/oslo/blob/master/sage/afsr.sage}\,.
  \begin{lstlisting}
    sage: adic_seq(-4,5,2,20)
    (-4, 5, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1])
    sage: a=adic_seq(-4,5,2,20)[2]
    sage: for i in range(3,20):
    ...:     print i,rational_synthesis_xu(a[0:i],2)
    ...:     
    3 (0, 1)
    4 (-4, 53)
    5 (-4, 53)
    6 (-4, 53)
    7 (-4, 5)
    8 (-4, 5)
    sage:
    sage: adic_seq(-17,77,2,40)
    (-17, 77, [1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1])
    sage: b=adic_seq(-17,77,2,40)[2]
    sage: for i in range(3,20):
    ...:     print i,rational_synthesis_xu(b[0:i],2)
    ...:     
    3 (-1, 9)
    4 (-5, 17)
    5 (-5, 17)
    6 (1, 3)
    7 (1, 3)
    8 (1, 3)
    9 (-13, 89)
    10 (-167, 1419)
    11 (-67, 183)
    12 (-89, 885)
    13 (-89, 885)
    14 (-89, 885)
    15 (359, 2229)
    16 (359, 2229)
    17 (359, 2229)
    18 (359, 2229)
    19 (359, 2229)
    20 (-17, 77)
    21 (-17, 77)
    22 (-17, 77)
    23 (-17, 77)
  \end{lstlisting}

  \par The $N$-adic sequences for $\alpha=\frac{-4}{5}$ and $\beta=\frac{-17}{77}$
  have small periods, so Xu's algorithm quickly converges to the correct $\alpha$
  and $\beta$. 
\end{example}

\begin{example}
  \par In this next example, the period of the approximated rational
  number $\gamma=\frac{-98}{2^{1000}-1}$ equals 1000.
  \begin{lstlisting}
    sage:adic_seq(-98,2^1000-1,2,20)
    (-98, 107150860718626732094842504906000..., [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    sage: d=adic_seq(-98,2^1000-1,2,10000)[2]
    sage: for i in range(3,2000):                           
    ...:    print i,rational_synthesis_xu(d[0:i],2)
    ...:     
    3 (-2, 9)
    4 (2, 1)
    5 (2, 1)
    6 (2, 1)
    7 (-22, 69)
    8 (-22, 69)
    9 (-302, 1209)
    10 (-302, 1209)
    11 (-302, 1209)
    12 (-302, 1209)
    13 (-302, 1209)
    14 (-134, 333)
    15 (-134, 333)
    16 (-134, 333)
    17 (-134, 333)
    18 (-134, 333)
    19 (-2818, 10671)
    20 (-2818, 10671)
    21 (-2818, 10671)
    22 (-2818, 10671)
    23 (-2818, 10671)
    24 (-26954, 85323)
    25 (-26954, 85323)
    26 (-26954, 85323)
    27 (-26954, 85323)
    28 (-26954, 85323)
    29 (98, 1)
    30 (98, 1)
    31 (98, 1)
    32 (98, 1)
    .
    .
    .
    2501 (-32524788108326247..., 180020230874340668557...)
    2502 (-98, 107150860718626732094842504906000...)
  \end{lstlisting}
  \par The algorithm does not
  converge nearly as fast as it did from approximating $\alpha$, but it
  eventually reaches the correct $\gamma_n$ at $n=2502$. It took
  approximately 1.25s for my computer to arrive at the correct approximation.
\end{example}

\section{Boolean Sequences}\label{sec:boolean-sequences}
\par The interest of this paper is stream ciphers, and there are a few
different ways to use bent functions in the implementation of a stream
cipher. Sequences generated using bent functions have nice cryptographic
properties because of their perfect nonlinearity. These sequences can be
generated multiple ways. Two easy examples are a filtering function on a
shift register producing an $m$-sequence or a shift register which uses $n$
different shift registers as input into a bent function. These two
techniques are discussed by Carlet \cite{col:c06}. Both of these
constructions use input vectors from $\gftwo^n$ in a pseudorandom order to
generate the sequence. Before scrambling the input in this way, the
sequences generated by binary ordering of input vectors is
considered.

\begin{definition}
  Let $(a_n)$ be a sequence. If $T$ is the smallest positive integer such that
  $a_i=a_{i+T}$, then the {\em minimal\ period} of $(a_n)$ is $T$.
\end{definition}

\begin{definition}\label{def:lex-Bool-seq}
  Let $f\in\BF_n$ and $v_i\in\gftwo^n$ such that $v_i=B^{-1}(i)$ for
  $0\leq i<2^n$. Then,
  \begin{equation}
    seq(f)=(f(v_0),f(v_1),\dots,f(v_{2^n-1}),f(v_0),\dots)
  \end{equation}
  is a {\em $f$-filtered\ Boolean\ sequence}.
\end{definition}

\par Defined in this way, all $f$-filtered Boolean sequences have a
minimal period at most $2^n$. Using the binary ordering, the Boolean
sequence generated will be repeated columns of the outputs for the Boolean
function read from the truth table of the Boolean function. For example, the
$f$-filtered Boolean sequence in Table \ref{tab:truth-table} is
\[
(0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1,\dots).
\]

\begin{theorem}
  The $f$-filtered Boolean sequence of a bent function has a period
  exactly $2^n$.
\end{theorem}
\begin{proof}
  For $x_i,\lambda_i\in\gftwo$ and $0\leq i\leq n-2$, define
  $(x,1)=\allowbreak(x_0,\dots,\allowbreak x_{n-2},1)$,
  $(x,0)=\allowbreak(x_0,\dots,\allowbreak x_{n-2},0)$, and
  $(\lambda,1)=\allowbreak(\lambda_0,\dots,\allowbreak \lambda_{n-2},1)$.
  Suppose $f\in\BF_n$ and $seq(f)$ has a period $T=2^j<2^n$. Then,
  $f(x,0)=f(x,1)$.
  {\allowdisplaybreaks
  \begin{align*}
    c(\lambda,1)&=\frac{1}{2^{n/2}}
      \left(\sum_{x\in\gftwo^{n-1}}
        {(-1)^{f(x,0)+(x,0)\cdot(\lambda,1)}+
        (-1)^{f(x,1)+(x,1)\cdot(\lambda,1)}}
      \right)\\
    &=\frac{1}{2^{n/2}}
      \left(\sum_{x\in\gftwo^{n-1}}
        {(-1)^{f(x,0)}\left((-1)^{(x,0)\cdot(\lambda,1)}+
        (-1)^{(x,1)\cdot(\lambda,1)}\right)}
      \right)\\
    &=\frac{1}{2^{n/2}}
      \left(\sum_{x\in\gftwo^{n-1}}
      {(-1)^{f(x,0)}\left((-1)^{0\cdot1}+(-1)^{1\cdot1}\right)}
      \right)\\
    &=\frac{1}{2^{n/2}}
      \left(\sum_{x\in\gftwo^{n-1}}{(-1)^{f(x,0)}\cdot0}\right)\\
    &=0.
  \end{align*}
  }
  One of the Fourier coefficients of $f$ must equal zero. Thus, $f$ cannot
  be a bent function. Clearly, every $f$-filtered Boolean sequence has a
  minimal period at most $2^n$. Therefore, if $g$ is a bent function, then
  $seq(g)$ has period exactly $2^n$.
\end{proof}

\par Boolean sequences will be considered as 2-adic exansions of rational
numbers.

\begin{definition}\label{2-adic-ex}
  Let $f\in\BF_n$ and $v_i\in\gftwo^n$ such that $v_i=B^{-1}(i)$ for
  $0\leq i<2^n$. Then,
  \begin{equation}
    \alpha_f=(f(v_0),f(v_0)+f(v_1)\cdot2,\dots,\allowbreak
      f(v_0)+\cdots\allowbreak+f(v_i)\cdot2^i,\allowbreak\dots)
  \end{equation}
  where $\alpha_f\in\zzz_2$ is called the {\em 2-adic\ expansion} of $f$.
\end{definition}

\begin{lemma}
  The digit representation of $\alpha_f$ is $seq(f)$.
\end{lemma}

\par Recall the Maiorana-McFarland class of Boolean functions from Section
\ref{subsec:bent-constructions}, and consider
the subset of these functions where $g(y)=0$. Then the following theorem is
true.

\begin{theorem}
  $\log_2(\alpha_f)=2^{n/2}+2^{\bar{\pi}(0)} $ where
  $f=x\cdot\pi(y)$.
\end{theorem}
\begin{proof}
  \par Let $f(x,y)=x\cdot\pi(y)$ and
  $(x,y)=(x_0,\dots,x_{n-1},y_0,\dots,y_{n-1})\in\gftwo^n$ where
  $x,y\in\gftwo^{n/2}$. Define $v_i=(x,y)_i=B^{-1}(i)$ for $0\leq i\leq
  2^{n}-1$. Then $y=0$ for $0\leq i\leq2^{n/2}-1$ and $x=0$ for $i=2^{n/2}$.
  Thus, $f(v_i)=0$ for $0\leq i \leq 2^{n/2}$.
  \par Now, $\log_2(\alpha_f)={\rm min}\{i:f(v_i)=1\}$. The claim is that
  ${\rm min}\{i:f(v_i)=1\}=2^{n/2}+2^{\bar{\pi}(0)}$.
  \par Let $A=\{(x,y)_i:2^{n/2}\leq i\leq 2^{n/2+1}-1\}$. Then $A$ is the set of
  vectors in $\gftwo^n$ where
  \[
    y_k=
    \begin{cases}
      1 \text{ if } k=0\\
      0 \text{ if } k>0\\
    \end{cases}
  \]
  If $u=(x,y)\in A$, then
  \[
    f(u)=x_{\bar{\pi}(0)}y_0=
    \begin{cases}
      1 \text{ if } x_{\bar{\pi}(0)}=1\\
      0 \text{ if } x_{\bar{\pi}(0)}=0
    \end{cases}
  \]
  Then $f(u)=1$ for exactly $2^{n/2-1}$ distinct elements $u\in A$.
  \par Define $(x',y')$ such that
  \[
    x_k'=
    \begin{cases}
      1 \text{ if } k=\bar{\pi}(0)\\
      0 \text{ if } k\not=\bar{\pi}(0)
    \end{cases}
    \hspace{5mm}
    y_k'=
    \begin{cases}
      1 \text{ if } k=0\\
      0 \text{ if } k\not=0
    \end{cases}
  \]
  Then $B(x',y')\leq B(u)$ for all $u\in A$. Thus, $i=B(x',y')$ is the smallest
  $i$ such that $f(v_i)=1$ and $v_i\in A$. $f(v_i)=0$ for $0\leq i\leq 2^{n/2}$.
  \par Therefore $\log_2(\alpha_f)=2^{n/2}+2^{\bar{\pi}(0)}$.
\end{proof}

\nocite{*}
\bibliography{refs}{}
\bibliographystyle{amsplain}
\end{document}
