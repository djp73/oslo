\section{Shift Registers}\label{sec:shift-registers}
\par The {\it feedback with carry shift register} (or FCSR) is a type of
shift register used in stream ciphers. Though there exist attacks against
this type of shift register by itself, it is possible to combine FCSRs
together in ways that no known attacks are useful. This however does not
guarantee security because the combining of the FCSRs greatly increases the
complexity of the cryptanalysis on the stream cipher. Despite the security
challenges, the speed of an FCSR implementation is very attractive for
engineers of hardware based cryptosystems.

\par This section will be used as an introduction to finite state machines
and feedback with carry shift registers. The FCSR will be considered in the
binary case and analyzed using $\zzz_2$. This analysis is then extended to
the case when bent sequences which could be generated by FCSRs, which leads to
the main result in Section~\ref{sec:boolean-sequences}.

\subsection{Finite State Machines}
\par It is appropriate to preface the discussion about FCSRs with general finite
state machines. Solomon W. Golomb's book {\em Shift Register Sequences}
\cite{bk:g82}, written in 1967 and revised in 1982, established a definition of
finite state machines and shift registers used in much of the literature today.

\begin{definition}\label{finite-state-machine}
  A {\em finite state machine} consists of a finite collection of {\em states}
  $K$, which sequentially accepts a sequence of {\em inputs} from a finite set
  $A$, and produces a sequence of {\em outputs} from a finite set
  $B$. Moreover, there is an {\em output function} $\mu$ which computes
  the present output as a fixed function of present input and present state,
  and a
  {\em next state function} $\delta$ which computes the next states as a fixed
  function of present input and present state. In a more mathematical manner,
  $\mu$ and $\delta$ are defined such that
  \begin{eqnarray}
    \mu:K \times A \rightarrow B \quad &\mu(k_n,a_n)=b_n \\
    \delta:K \times A \rightarrow K \quad &\delta(k_n,a_n)=k_{n+1}
  \end{eqnarray}
\end{definition}

% insert table example of a finite state machine

\par The most fundamental observation by Golomb is the following proposition.
Its result guarantees the periodicity of any finite state machine with
eventually periodic input.

\begin{proposition}\label{prop:golomb-2}
  If the input sequence to a finite state machine is eventually periodic, then
  the output sequence is eventually periodic.
\end{proposition}
\begin{proof}
  Let $p$ be the period of the inputs once the machine becomes periodic at time
  $t$. Then, for $h>0$ and $c>t$, $a_c=a_{c+hp}$. Since $K$ is finite, there
  must be $r>s>t$ such that, for some $h>0$ such that,
  \[
  k_{r+1}=\delta(k_r,a_r)=\delta(k_s,a_{r+hp})=k_{s+1}.
  \]
  It should also be clear that $a_{r+i}=a_{r+i+hp}$ for $h>0$. So by induction,
  $\forall i>0$
  \[
  k_{r+i+1}=\delta(k_{r+i},a_{r+i})=\delta(k_{s+i},a_{r+i+hp})=k_{s+i+1}
  \]
  Finally, this proves $b_{r+i+1}=b_{s+i+1}$. Thus, the eventual period of this
  machine is $r-s$.
\end{proof}

\par The next object defined is called an $N$-ary $n$-stage machine. It can be
used to represent any finite state machine. It is also a natural generalization
of shift registers, so thinking of finite state machines in the context of
$N$-ary $n$-state machines will make the transition to talking about shift
registers much smoother.

\begin{definition}\label{N-ary-n-stage-machine}
  Choose $n,m,r\in\nnn$. Then define a finite state machine with the
  following sets:
  \begin{enumerate}[1.]
    \item $D=\{0,\dots,N-1\}$. This set contains the {\em $N$-ary digits} of the
      machine.
    \item $K=\{\sum_{i=0}^{n-1}x_iN^i:x_i\in D\}$. This set contains the
      {\em $N$-ary states} of the machine.
    \item $A=\{\sum_{i=0}^{m-1}y_iN^i:y_i\in D\}$. This set contains the
      {\em $N$-ary inputs} of the machine.
    \item $B=\{\sum_{i=0}^{r-1}z_iN^i:z_i\in D\}$. This set contains the
      {\em $N$-ary outputs} of the machine.
    \item $\Delta=\{\delta_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}):0\le i<n\}$ where
      $\delta_i:K\times A\rightarrow D$. This set contains the {\em $N$-ary next state functions} of the machine.
    \item $M=\{\mu_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}):0\le i<r\}$.
      $\mu_i:K\times A\rightarrow D$. This set contains the {\em $N$-ary output functions} of the machine.
  \end{enumerate}
  The next state and output are determined from the current state and input by the
  following equations:
  \begin{eqnarray}
    x_i^*=\delta_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}) \quad 0\le i<n \\
    z_i=\mu_i(x_0,\dots,x_{n-1},y_0,\dots,y_{m-1}) \quad 0\le i<r
  \end{eqnarray}
  This finite state machine is called an {\em $N$-ary $n$-stage machine} and
  will be denoted by $\mathcal{M}(N,n,m,r)$.
\end{definition}

\par By making the state the input to the machine as well, this machine
becomes autonomous in the sense that it no longer needs outside input. Then
each new state and output is based on the previous state of the machine. For
$N=2$, $f_i$ and $g_i$ are Boolean functions on $n+m$ variables.
A binary $n$-stage machine can be defined by $n+r$ Boolean functions each
on $n+m$ variables.

\subsection{Feedback with Carry Shift Registers}

\par In the set of autonomous finite state machines is a type of machine
called a {\it shift register}. The variables making up the state of a shift
register pass their values directly to the next variable in the state until
the value is pushed out of the register as the output. Here, what was referred
as an $n$-stage machine will now be called an $r$-stage machine as $n$ will be
used to index the output sequences of FCSRs.

\begin{definition}\label{def:shift-register}
  Let $\mathcal{M}(2,r,-1,0)$ be an binary $r$-stage machine with no input
  and exactly 1 output value. Also, let $g,f_i\in\BF_n$ where the states
  $(x_0,\dots,x_{r-1})$ are the domain of $g$ and $f_i$, $f_i(x)=x_{i+1}$ for
  $0\leq i \leq n-2$, and $g(x)=x_0$. This type of machine will be denoted
  by $\mathcal{SR}(2,r)$.
\end{definition}

\par When the function $f_{r-1}\in\BF_r$ is linear, then $\mathcal{SR}(2,r)$ is
called a {\it linear feedback shift register}. An LFSR is drawn in Figure
\ref{fig:LFSR}. This is the case where $f_{r-1}=\sum_{i=1}^rq_ix_{r-i}$ where
each $x_i,q_i \in \gftwo$. The $q_i$'s are called {\it taps}. In computer
science terms, to move forward in the sequence of states, each bit in the state
of the register shifts to the right one spot and then the newest bit enters
on the left end of the register and is the value given when each bit from
the previous state is AND'ed with its corresponding tap and then XOR'ed with
all the other AND'ed bit and taps.

\setlength{\unitlength}{1mm}
\begin{figure}[h!]
  \centering
  \begin{picture}(90,40)(-25,-25)
    %% State of the register
    \put(0,0){\framebox(10,10){$x_{n-1}$}}
    \put(10,0){\framebox(10,10){$x_{n-2}$}}
    \put(20,0){\framebox(10,10){$\dots$}}
    \put(30,0){\framebox(10,10){$x_{1}$}}
    \put(40,0){\framebox(10,10){$x_{0}$}}
    \put(50,5){\vector(4,0){10}}
    %% Taps
    \put(0,-13){\makebox(10,10){$q_1$}}
    \put(5,-8.5){\circle{9}}
    \put(10,-13){\makebox(10,10){$q_2$}}
    \put(15,-8.5){\circle{9}}
    \put(20,-13){\makebox(10,10){$\dots$}}
    \put(30,-13){\makebox(10,10){$q_{n-1}$}}
    \put(35,-8.5){\circle{9}}
    \put(40,-13){\makebox(10,10){$q_r$}}
    \put(45,-8.5){\circle{9}}
    %% Lines connecting Taps and the State of the Register
    \multiput(5,-0.2)(10,0){2}{\line(0,-6){4}}
    \multiput(35,-0.2)(10,0){2}{\line(0,-6){4}}
    %% Summer
    \put(-20,-25){\framebox(10,10){\Large $\sum$}}
    %% Lines from Taps to Summer
    \put(5,-12.8){\line(0,-6){3.5}}
    \put(15,-12.8){\line(0,-6){5.5}}
    \put(35,-12.8){\line(0,-6){8.5}}
    \put(45,-12.8){\line(0,-6){10.5}}
    \put(5,-16.3){\vector(-4,0){15}}
    \put(15,-18.3){\vector(-4,0){25}}
    \put(35,-21.3){\vector(-4,0){45}}
    \put(45,-23.3){\vector(-4,0){55}}
    %% Lines from Summer
    \put(-13,-15){\line(0,0){20}}
    \put(-13,5){\vector(4,0){13}}
    %% mod N
    \put(-13,5){\makebox(13,5){mod 2}}
  \end{picture}
  \caption{Linear Feedback Shift Register}
  \label{fig:LFSR}
\end{figure}

\par Linear feedback shift registers are well-studied in \cite{bk:g82}. By
using the Berlekamp-Massey algorithm it is possible to recover the state of
a given LFSR based on the output sequence. In fact given an LFSR output sequence
with period $2^r-1$, the Berlekamp-Massey algorithm will find a unique
minimal-length LFSR which generates this output after the first $2n$ digits have
been processed \cite{art:m69}. This algorithm is studied in more detail in
\cite{art:b06}.

\par In Figure \ref{fig:FCSR}, there is a memory cell attached to the linear
feedback shift register which adds some complexity to the register. In the
modified shift register shown in Figure \ref{fig:FCSR}, in each cycle, the
whole number quotient of $\sum_{i=1}^rq_ix_{r-i}$ is kept in the memory cell
$z$. The memory cell from the previous state of the modified shift register
is used to determined the sum modulo 2 for the newest bit in the state of
the register. A shift register modified in this way is known as a {\it
binary feedback with carry shift register}, or FCSR. For this paper, FCSRs
will only be considered in the binary case. Many of the theorems do
generalize the $N$-ary case, though sometimes it is necessary that $N$ be
prime.

\begin{figure}[h!]
  \centering
  \begin{picture}(90,40)(-40,-25)
    %% State of the register
    \put(0,0){\framebox(10,10){$x_{r-1}$}}
    \put(10,0){\framebox(10,10){$x_{r-2}$}}
    \put(20,0){\framebox(10,10){$\dots$}}
    \put(30,0){\framebox(10,10){$x_{1}$}}
    \put(40,0){\framebox(10,10){$x_{0}$}}
    \put(50,5){\vector(4,0){10}}
    %% Taps
    \put(0,-13){\makebox(10,10){$q_1$}}
    \put(5,-8.5){\circle{9}}
    \put(10,-13){\makebox(10,10){$q_2$}}
    \put(15,-8.5){\circle{9}}
    \put(20,-13){\makebox(10,10){$\dots$}}
    \put(30,-13){\makebox(10,10){$q_{r-1}$}}
    \put(35,-8.5){\circle{9}}
    \put(40,-13){\makebox(10,10){$q_r$}}
    \put(45,-8.5){\circle{9}}
    %% Lines connecting Taps and the State of the Register
    \multiput(5,-0.2)(10,0){2}{\line(0,-6){4}}
    \multiput(35,-0.2)(10,0){2}{\line(0,-6){4}}
    %% Summer
    \put(-20,-25){\framebox(10,10){\Large $\sum$}}
    %% Lines from Taps to Summer
    \put(5,-12.8){\line(0,-6){3.5}}
    \put(15,-12.8){\line(0,-6){5.5}}
    \put(35,-12.8){\line(0,-6){8.5}}
    \put(45,-12.8){\line(0,-6){10.5}}
    \put(5,-16.3){\vector(-4,0){15}}
    \put(15,-18.3){\vector(-4,0){25}}
    \put(35,-21.3){\vector(-4,0){45}}
    \put(45,-23.3){\vector(-4,0){55}}
    %% Lines from Summer
    \put(-13,-15){\line(0,0){20}}
    \put(-13,5){\vector(4,0){13}}
    \put(-17,-15){\line(0,0){20}}
    \put(-17,5){\vector(-4,0){13}}
    %% Memory cell z
    \put(-40,0){\framebox(10,10){$z$}}
    %% Lines from memory cell to summer
    \put(-35,0){\line(0,-6){20}}
    \put(-35,-20){\vector(4,0){15}}
    %% div 2 mod 2
    \put(-13,5){\makebox(13,5){mod $2$}}
    \put(-29.5,5){\makebox(13,5){div $2$}}
  \end{picture}
  \caption{Binary Feedback with Carry Shift Register} 
  \label{fig:FCSR}
\end{figure}

\begin{definition}\label{def:fcsr}
  Let $q_1,\dots,q_r\in{0,1}\subset\zzz$ and $q_0=-1$. A {\em binary feedback with carry shift register} 
  of length $n$ with {\em taps} $q_1,\dots,q_r$ is a modified shift register
  whose states are collections
  \[
  (x_0,x_1,\dots,x_{r-1};z) \text{ where } x_i\in\gftwo \text{ and } z \in \zzz
  \]
  where $z$ is called the {\it memory cell}. The state changes according
  to the following rules:
  \begin{enumerate}[1.]
    \item Compute
      \[
        \sigma_n = \sum^r_{i=1}q_ia_{n-i}+z_{n-1}.
      \]
    \item The output is $x_0$.
    \item Then the new state $(x_0,x_1,\dots,x_{n-1};z)
      =(x_1,\dots,x_{n-1},\sigma_n\pmod2;\sigma_n(\text{div }2))$.
  \end{enumerate}
\end{definition}

\begin{lemma}\label{lem:linear-recur}
\par If the sequence $\alpha=(a_0,a_1,\dots)$ where $a_i\in\{0,1\}$ and
$a_i\equiv x_i\pmod2$, and $\zeta=(z_{n-1},z_n,z_{n+1},\dots)$ where each
$z_i$ is the value of the memory cell for the corresponding $x_i$, then
these two sequences are related by the following linear recurrence
\begin{equation}\label{eqn:lin-rec}
  a_k+2z_k=q_1a_{k-1}+\cdots+q_ra_{k-r}+z_{k-1} \text{ for } k\geq r.
\end{equation}
\end{lemma}

\par Recall from Proposition~\label{prop:golomb-2} that an FCSR must be
eventually periodic. By Proposition~\label{prop:rational-periodic}, the sequence
generated by every FCSR can then be represented by a rational number in
$\zzz_2$. This rational number, or sequence generated, is entirely determined by
the initial state and the taps of the register.

\begin{proposition}{\rm \cite{art:kg97}}\label{prop:FCSR-seq}
  Let $q_1,\dots,q_r$ be the taps, $z_{r-1}$ be the initial memory, and
  $a_{r-1},\dots,a_1,a_0$ be the initial state of an FCSR. Define
  $q=1+\sum_{i=1}^{r}q_i2^i$ and
  \begin{equation*}
    p=\left(\sum_{i=0}^{r-1}\sum_{j=0}^iq_ja_{i-j}2^i\right)-z_{r-1}2^r.
  \end{equation*}
  Then the output sequence ${\bf a}$ of this FCSR is the digit representation of
  the 2-adic integer
  \begin{equation}\label{eqn:alpha}
    \alpha=\sum_{i=0}^\infty a_i2^i=p/q.
  \end{equation}
\end{proposition}
\begin{proof}
  Consider the transition from one state of the FCSR to the next. Suppose that,
  for some given state, the value of the memory is $z_{n-1}$ and that the
  contents of the register is given by the $r$ bits $a_{n-1},\dots,a_{n-r}$.
  The next state of the register is determined by calculating
  \begin{equation*}
    \sigma_n=z_{n-1}+\sum_{i=1}^rq_ia_{n-i},
  \end{equation*}
  writing the new memory contents as $z_n=\sigma_n(\text{div }2)$, and writing
  the new contents of the state $a_n=\sigma_n\pmod2$. As stated in Lemma
  \ref{lem:linear-recur}, these equations may be combined into the expression
  \[
    \sigma_n=2z_n+a_n.
  \]
  It follows that
  \begin{equation}\label{eqn:an}
    a_n=\sum_{i=1}^rq_ia_{n-i}+(z_{n-1}-2z_n),
  \end{equation}
  for $n\geq r$. Now, by substituting Equation~(\ref{eqn:an}) into Equation
  (\ref{eqn:alpha}),
  \begin{align}
    \alpha&=a_0+a_1 2+\cdots+a_{r-1}2^{r-1}+\sum_{n=r}^\infty a_n2^n \notag\\
          &=x+\sum_{n=r}^\infty\left( \sum_{i=1}^r q_ia_{n-i} \right)2^n
          +\sum_{n=r}^\infty (z_{n-1}-2z_n)2^n. \label{eqn:alpha-fcsr}
  \end{align}
  where $x=\sum_{i=0}^{r-1}a_i2^i$ is the integer represented by the initial
  state of the register. The second summation in Equation~(\ref{eqn:alpha-fcsr})
  cancels except for the first term, $z_{r-1}$, leaving
  \begin{align*}
    \alpha&=x+z_{r-1}2^r+\sum_{n=r}^\infty\sum_{i=1}^r q_i2^ia_{n-i}2^{n-i}\\
          &=x+z_{r-1}2^r+\sum_{i=1}^r{q_i2^i}\left(\sum_{n=r}^\infty a_{n-i}2^{n-i}\right)\\
          &=x+z_{r-1}2^r+\sum_{i=1}^r{q_i2^i}(\alpha-(a_02^0+a_12^1+\cdots+a_{r-i-1}2^{r-i-1}))\\
          &=x+z_{r-1}2^r+\alpha\sum_{i=1}^r{q_i2^i}-\sum_{i=1}^{r-1}\sum_{j=0}^{r-i-1}q_i2^ia_j2^j.
  \end{align*}
  (where the inner sum is empty, hence zero, when $i=r$ in the third line).
  These equations give
  \begin{align*}
    \alpha&=\frac{x+z_{r-1}2^r-\sum_{i=1}^{r-1}\sum_{j=0}^{r-i-1}q_i2^ia_j2^j}
                {1-\sum_{i=1}^r q_i2^i}\\
          &=\frac{\sum_{i=0}^{r-1}\sum_{j=0}^{r-i-1}q_i2^ia_j2^j-z_{r-1}2^r}{q}
  \end{align*}
  since $q_0=-1$. The double summation is over all pairs of integers $0\leq i,j
  \leq r-1$ with $i+j\leq r-1$. Setting $k=i+j$ gives
  \begin{equation}\label{eqn:fcsr-seq}
    \alpha=\frac{\left(\sum_{k=0}^{r-1}\sum_{i=0}^kq_ia_{k-i}2^k\right)-z_{r-1}2^r}{q}
          =\frac{p}{q}
  \end{equation}
  as claimed.
\end{proof}

\begin{corollary}
  \par Changing the memory by $b$ changes the value of $\alpha$ by $-b2^r/q$. If
  $\alpha=p/q<0$, then the initial memory $z_{r-1}\geq 0$.
\end{corollary}
\begin{proof}
  \par The first statement follows trivially from Equation~(\ref{eqn:fcsr-seq}).
  \par The second statemtent is not as obvious. If $q<0$, then the numerator
  must be positive for $p/q$ to be negative. Since
  \begin{equation}\label{eqn:memory-v-initial_state}
    z_{r-1}2^r\geq\sum_{k=0}^{r-1}\sum_{i=0}^kq_ia_{k-i}2^k\geq0,
  \end{equation}
  this implies $z_{r-1}=0$. If $q>0$, then the numerator must negative.
  By Equation~(\ref{eqn:memory-v-initial_state}), $z_{r-1}>0$. Therefore,
  $z_{r-1}\geq0$.
\end{proof}

\par It can also be shown that the memory cell of every FCSR is bounded and
eventually lies between 0 and ${\rm wt(q+1)}$, for $q>0$.

\begin{proposition}{\rm \cite{art:kg97}}\label{prop:mem-bound}
  \par Let $w={\rm wt}(q+1)$. If an FCSR is in a periodic state, then the memory
  is in the range $0\leq z<w$. If the initial memory $z_{n-1}\geq w$, then it
  will monotonically decrease and will arrive in the range $0\leq z<w$ within
  $\lfloor\log_2(z_{n-1}-w)\rfloor+r$ steps. If the initial memory $z_{n-1}<0$,
  then it will monotonically increase and will arrive in the range $0\leq z<w$
  within $\lceil\log_2(|z_{n-1}|)\rceil+r$ steps. (The logarithm functions in
  this proposition will be real-valued.)
\end{proposition}
\begin{proof}
  \par First, observe that if the initial memory value $z_{n-1}$ lies in the
  range $0\leq z_{n-1}<w$, then the same will be true for all later values of
  the memory. This follows from Definition~\ref{def:fcsr} because
  $\sigma_n = \sum^r_{i=1}q_ia_{n-i}+z_{n-1} \leq w+z_{n-1} < 2w$. So
  $z_n=\lfloor\sigma_n/2\rfloor<w$.
  \par By the same argument, if the initial memory value is $z_{n-1}=w$, then
  the later values of memory will be no greater than $w$; but in this case,
  within $r$ steps, the memory will drop below $w$ (and will remain so
  thereafter) for the following reason. If the memory does not decrease (i.e.
  $z_n=w$), then this means that a 1 appeared at {\it all} the tapped cells,
  that $\sigma_n=2w$, and that $x_n=\sigma_n\pmod2=0$ was fed into the register.
  The value of $\sigma$ will fall below $2w$ when this 0 reaches the first
  tapped cell (if not before), at which time we will have
  $z=\lfloor\sigma/2\rfloor<w$.
  \par Moreover, if we initialize an FCSR with a larger memory value,
  $z_{n-1}>w$, then with each step, the excess $e_{n-1}=z_{n-1}-w$ will become
  reduced by a factor of 1/2, that is $e_n\leq\lfloor e_{n-1}/2\rfloor$. So
  after $\lfloor\log_2(z_{n-1}-w)\rfloor+1$ steps, the memory will be no more
  than $w$. This follows from Definition~\ref{def:fcsr} which gives
  \[
    e_n=z_n-w=\left\lfloor\frac{\sigma_n}{2}\right\rfloor-w
    \leq\left\lfloor\frac{w+w+e_{n-1}}{2}\right\rfloor-w
    =\left\lfloor\frac{e_{n-1}}{2}\right\rfloor.
  \]
  Now consider the case of negative initial memory, $z_{n-1}<0$. By Definition
  \ref{def:fcsr}, it is possible that $\sigma_n\geq0$, in which case the next
  memory value will be $z_n\geq0$ (where it will remain thereafter). So suppose
  that $\sigma_n<0$. Then, again by Definition~\ref{def:fcsr},
  \[
    |z_n|\leq\frac{|\sigma_n|+1}{2}\leq\frac{|z_{n-1}|+1}{2}.
  \]
  Iterating this formula, it is easy to see that after
  $K=\lceil\log_2(|z_{n-1}|)\rceil$ steps, either the memory $z$ has become
  nonnegative, or else
  \[
    |z|\leq\frac{z_{n-1}}{2^K}+\frac{1}{2^K}+\frac{1}{2^{K-1}}+\cdots+\frac{1}{2}<2
  \],
  in which case the memory must be $m=-1$. There is a single situation in which
  the memory can remain at $-1$ forever: if there are no feedback taps on the
  shift register (so $q=-1$). In this case, the memory will feed 1s into the
  shift register forever. However, we assumed that $q>0$ to rule out this
  possibility. If $q>0$, then as soon as a nonzero feedback occurs, the memory
  will become nonnegative, where it will remain thereafter.
\end{proof}

\par Prosition \ref{prop:mem-bound} shows that eventually every FCSR reaches
a point where there are a
finite number of inputs from the memory cells and of states. This means that
every FCSR eventually satisfies the definition of a finite state machine. As a
result, the output of every FCSR is eventually periodic. In Section
\ref{sec:n-adic-ring}, it was shown than every eventually periodic sequence of
0s and 1s corresponds to an $\alpha=p/q\in\zzz_2$. This fact makes FCSRs
extremely vulnerable to rational approximation algorithms.

\subsection{FCSR Synthesis}
\par The problem of synthesis lies in the following question: Given an eventually
periodic sequence of 0s and 1s generated by an FCSR, can you find $a$ and $b$
such that sequence generated is equivalent to digit representation of
$\frac{a}{b}\in\zzz_2$. If there are no constraints on $a$ and $b$, then 
at least a period of the sequence must be known to solve the problem. However,
every FCSR is limited to a certain number of $p/q\in\zzz_2$ that it can generate
become of memory restrictions. The rational approximation algorithm shown in this paper
uses the fact that only so many possibilities exist for a given FCSR to show
that it will eventually reach the correct approximation in a finite number of
steps.  As a quick example of this, consider the FCSR in Figure
\ref{fig:FCSR-4over5}. By Proposition~\ref{prop:FCSR-seq}, it should be clear
that the initial states, taps, and memory completely determine the 2-adic integer
represented by the sequence generated. Both the initial states and taps are
finite, and the memory is bounded at the initial stage of the register.

\begin{figure}[h!]\label{fig:FCSR-4over5}
  \setlength{\unitlength}{1mm}
  \centering
  \begin{picture}(90,40)(-40,-25)
    %% State of the register
    \put(0,0){\framebox(10,10){1}}
    \put(10,0){\framebox(10,10){1}}
    \put(20,0){\framebox(10,10){$0$}}
    \put(30,0){\framebox(10,10){$0$}}
    \put(40,5){\vector(4,0){10}}
    %% Taps
    \put(0,-13){\makebox(10,10){1}}
    \put(5,-8.5){\circle{9}}
    \put(10,-13){\makebox(10,10){1}}
    \put(15,-8.5){\circle{9}}
    \put(20,-13){\makebox(10,10){0}}
    \put(25,-8.5){\circle{9}}
    \put(30,-13){\makebox(10,10){0}}
    \put(35,-8.5){\circle{9}}
    %% Lines connecting Taps and the State of the Register
    \multiput(5,-0.2)(10,0){4}{\line(0,-6){4}}
    %% Summer
    \put(-20,-25){\framebox(10,10){\Large $\sum$}}
    %% Lines from Taps to Summer
    \put(5,-12.8){\line(0,-6){3.5}}
    \put(15,-12.8){\line(0,-6){5.5}}
    \put(25,-12.8){\line(0,-6){8.5}}
    \put(35,-12.8){\line(0,-6){10.5}}
    \put(5,-16.3){\vector(-4,0){15}}
    \put(15,-18.3){\vector(-4,0){25}}
    \put(25,-21.3){\vector(-4,0){35}}
    \put(35,-23.3){\vector(-4,0){45}}
    %% Lines from Summer
    \put(-13,-15){\line(0,0){20}}
    \put(-13,5){\vector(4,0){13}}
    \put(-17,-15){\line(0,0){20}}
    \put(-17,5){\vector(-4,0){13}}
    %% Memory cell z
    \put(-40,0){\framebox(10,10){0}}
    %% Lines from memory cell to summer
    \put(-35,0){\line(0,-6){20}}
    \put(-35,-20){\vector(4,0){15}}
    %% div 2 mod 2
    \put(-13,5){\makebox(13,5){mod $2$}}
    \put(-29.5,5){\makebox(13,5){div $2$}}
  \end{picture}
  \caption{FCSR which generate the sequence
    $\frac{-4}{5}=00110011001100110011\cdots$}
\end{figure}

\par The FCSR in Figure~\ref{fig:FCSR-4over5} is meant as a simple visualization
how after fooling with all of the possible initial states and tap arrangements,
the size of the memory becomes the only means to create new possibilities in the
sequence generated. 

\subsection{Xu's Rational Approximation Algorithm}
\par It turns out that given a sequence generated by an FCSR it is easy to
reproduce to FCSR from which it came from. This is why using FCSRs by themselves
do not generate secure stream ciphers. If used as a stream cipher, the key for
the FCSR would be the taps and the initial state. All an attacker would need is
a relatively short piece of the output sequence to reveal every part of the key.
This ciphertext only attack is a complete break of the stream cipher. In fact, any
arrangement of taps and initial state of an FCSR can be revealed very quickly.
\par In Goresky and Klapper's book \cite{bk:gk12}, they describe in pseudocode Xu's rational
approximation algorithm for $\pi$-adic sequences in any ring $R$. A
demonstration of Xu's algorithm is presented here in the context of the ring
$\zzz_2$. The algorithm takes as input the first $n$ terms
of an $N$-adic sequence ${\bf a}=(a_0,a_1,\dots)$ associated to a rational
number $\alpha=p/q\in\zzz_2$ and outputs a rational number $\alpha_n=p'/q'$
whose first $n$ terms match
{\bf a}. Running Xu's algorithm for small $n$ can sometimes result in $\alpha_n$
which are far from $\alpha$, but in the examples below, it is easy to see that as
$n$ grows large, Xu's algorithm eventually reaches the correct $\alpha$. In
fact, for large enough $n$, Xu's algorithm will reach the correct $\alpha$.

\begin{example}
  This example uses the function {\ttfamily rational\_synthesis\_xu}
  from the {\ttfamily Sage} script {\ttfamily afsr.sage}. The source code for
  this function can be download from
  \url{https://github.com/celerier/oslo/blob/master/sage/afsr.sage}\,.
  \begin{lstlisting}
    sage: adic_seq(-4,5,2,20)
    (-4, 5, [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1])
    sage: a=adic_seq(-4,5,2,20)[2]
    sage: for i in range(3,20):
    ...:     print i,rational_synthesis_xu(a[0:i],2)
    ...:     
    3 (0, 1)
    4 (-4, 53)
    5 (-4, 53)
    6 (-4, 53)
    7 (-4, 5)
    8 (-4, 5)
    sage:
    sage: adic_seq(-17,77,2,40)
    (-17, 77, [1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1])
    sage: b=adic_seq(-17,77,2,40)[2]
    sage: for i in range(3,20):
    ...:     print i,rational_synthesis_xu(b[0:i],2)
    ...:     
    3 (-1, 9)
    4 (-5, 17)
    5 (-5, 17)
    6 (1, 3)
    7 (1, 3)
    8 (1, 3)
    9 (-13, 89)
    10 (-167, 1419)
    11 (-67, 183)
    12 (-89, 885)
    13 (-89, 885)
    14 (-89, 885)
    15 (359, 2229)
    16 (359, 2229)
    17 (359, 2229)
    18 (359, 2229)
    19 (359, 2229)
    20 (-17, 77)
    21 (-17, 77)
    22 (-17, 77)
    23 (-17, 77)
  \end{lstlisting}

  \par The $N$-adic sequences for $\alpha=\frac{-4}{5}$ and $\beta=\frac{-17}{77}$
  have small periods, so Xu's algorithm quickly converges to the correct $\alpha$
  and $\beta$. 
\end{example}

\begin{example}
  \par In this next example, the period of the approximated rational
  number $\gamma=\frac{-98}{2^{1000}-1}$ equals 1000.
  \begin{lstlisting}
    sage:adic_seq(-98,2^1000-1,2,20)
    (-98, 107150860718626732094842504906000..., [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    sage: d=adic_seq(-98,2^1000-1,2,10000)[2]
    sage: for i in range(3,2000):                           
    ...:    print i,rational_synthesis_xu(d[0:i],2)
    ...:     
    3 (-2, 9)
    4 (2, 1)
    5 (2, 1)
    6 (2, 1)
    7 (-22, 69)
    8 (-22, 69)
    9 (-302, 1209)
    10 (-302, 1209)
    11 (-302, 1209)
    12 (-302, 1209)
    13 (-302, 1209)
    14 (-134, 333)
    15 (-134, 333)
    16 (-134, 333)
    17 (-134, 333)
    18 (-134, 333)
    19 (-2818, 10671)
    20 (-2818, 10671)
    21 (-2818, 10671)
    22 (-2818, 10671)
    23 (-2818, 10671)
    24 (-26954, 85323)
    25 (-26954, 85323)
    26 (-26954, 85323)
    27 (-26954, 85323)
    28 (-26954, 85323)
    29 (98, 1)
    30 (98, 1)
    31 (98, 1)
    32 (98, 1)
    .
    .
    .
    2501 (-32524788108326247..., 180020230874340668557...)
    2502 (-98, 107150860718626732094842504906000...)
  \end{lstlisting}
  \par The algorithm does not
  converge nearly as fast as it did from approximating $\alpha$, but it
  eventually reaches the correct $\gamma_n$ at $n=2502$. It took
  approximately 1.25s for my computer to arrive at the correct approximation.
\end{example}

