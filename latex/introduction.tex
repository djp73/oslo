\section{Introduction}\label{sec:intro}
\par Bytes of data, or short sequences of 1s and 0s, are exchanged between
computer systems each day on public channels. Because gentlemen do read each
other's mail, it is necessary to secure the communication of private data
sent over public channels. The solution to this problem is solved by
{\em cryptography}, the designing of systems to secure data exchanges over
public channels.

\par The following example is the classical communication scenario presented
in many books on cryptography. Let there be two parties, Alice and Bob, who
wish to communicate with one another. A third party, Eve, is a potential
eavesdropper. Alice wants to send a message, known as the {\em plaintext},
to Bob. To accomplish this without Eve knowing what the message is before it
is received by Bob, Alice must {\em encrypt} her message by some prearranged
method, usually involving an {\em encryption key}, to generate a related
message called {\em ciphertext}. The idea is that the sent ciphertext, even
if it is intercepted by Eve, will be too difficult to interpret and will
conceal the plaintext message. Upon receipt of the ciphertext, Bob will
{\em decrypt} the message, usually involving a {\em decryption key}, similar
to the encryption of the message, and obtain the plaintext message. A visual
of this scenario is presented in Figure \ref{fig:basic-scenario}.

\begin{figure}[h!]\label{fig:basic-scenario}
	\centering
  %% The Basic Communication Scenario for Cryptography
  \setlength{\unitlength}{1mm}
  \begin{picture}(100,38)(-50,-19)
    \put(-50,-1.3){\framebox{Alice}}
    \put(0,0){\circle*{2}}
    \put(-39.9,0){\vector(4,0){15}}
    \put(-24.9,-1){\framebox{Encrypt}}
    \put(-10,0){\line(4,0){9}}
    \put(-38.4,2){\makebox{\footnotesize plaintext}}
    \put(-17.45,15){\vector(0,-4){12.2}}
    \put(-24,20){\makebox{\footnotesize encryption}}
    \put(-19.5,16.5){\makebox{\footnotesize key}}
    \put(-6.5,2){\makebox{\footnotesize ciphertext}}
    \put(1,0){\vector(4,0){9}}
    \put(0,-1){\vector(0,-4){12.2}}
    \put(-4.2,-17){\framebox{Eve}}
    \put(0,-13.2){\vector(0,4){12.2}}
    \put(10,-1){\framebox{Decrypt}}
    \put(24.9,0){\vector(4,0){15}}
    \put(26.1,2){\footnotesize plaintext}
    \put(39.9,-1.3){\framebox{Bob}}
    \put(17.45,15){\vector(0,-4){12.2}}
    \put(11,20){\makebox{\footnotesize decryption}}
    \put(15.5,16.5){\makebox{\footnotesize key}}
  \end{picture}
	\caption{The basic communication scenario for cryptography}
\end{figure}

\par This scenario is the standard example found in many different
introductory cryptography references. Cryptographers have created numerous
encryption and decryption schemes, or {\em cryptosystems}, to secure the
messages sent between Alice and Bob. Many of these systems have been broken
because of the amount of work that goes into the study of breaking
cryptosystems, called {\em cryptanalysis}. A constant battle exists between
the designers and breakers of cryptosystems, strengthening designs and
attacks every day. In fact, designing a strong cryptosystem typically
requires knowledge of cryptography and cryptanalysis. When designing a
cryptosystem, every cryptographer assumes {\em Kerckhoffs' principle}
\cite{bk:tw06}: ``In assessing the security of a cryptosystem, one should always
assume the enemy knows the method being used.'' The security of a cryptosystem
cannot be based on the concealment of the encryption and decryption algorithms.
In practice, the enemy can obtain the algorithms in many ways, including the
defection or capture of people. The security must be based solely on the key.

\par This paper will explore bent sequences for their potential strength in
{\it stream ciphers}. According to Rueppel in \cite{bk:r86}, a {\em stream cipher}
divides bit sequences into individual bits and enciphers each bit with a
time-varying function whose time-dependency is governed by the internal state
of the stream cipher.  The stream cipher can also be thought of in terms of a
{\em keystream} which is a sequence of 1s and 0s the same length of the
message that is added to the message using addition in $\gftwo$ (also known
as XOR). If the keystream was perfectly random, then the cryptosystem would
be unbreakable, or {\em perfectly secret}, as discovered by Claude Shannon
in his famous paper ``Communication Theory of Secrecy Systems,'' written
secretly in 1945 and published in 1949. This cryptosystem is known as the
{\em one-time pad}. Though it is perfectly secret, it can be difficult to
implement because of the inability to produce perfectly random keystreams.
Constructing a method to produce perfectly random sequences is a
contradiction in itself.

\par Though it is difficult to create perfectly random sequences, it is feasible
to get close. A sequence which is close to being random is called a
{\em pseudorandom sequence}. In \cite{bk:g82}, Golomb lists three randomness
postulates on periodic binary sequences:
\begin{enumerate}[R-1.]
	\item In every period, the number of 0s is nearly equal to the number of 1s.
	\item In every period, half the runs have length one, one-fourth have length
		two, one-eighth have length three, etc., as long as the number of runs so
		indicated exceeds 1. Moreover, for each of these lengths, there are equally
		many runs of 0s and of 1s.
	\item The auto-correlation function $C(\tau)$ is two-valued. Explicitly
		\begin{align*}
      C(\tau)=\frac{1}{p}\sum_{n=1}^p(-1)^{a_na_{n+\tau}}=
			\begin{cases}
				1 \text{if } \tau=0,\\
				K \text{if } 0<\tau<p.
			\end{cases}
		\end{align*}
\end{enumerate}
These postulates today have become a measure of how close a sequence is to being
considered pseudorandom. The claim is that binary sequences with extremely long
periods would be nearly indistinguishable from perfectly random binary
sequences.
\par In the case of this paper, the {\it $f$-filtered Boolean sequence} defined
in Section~\ref{sec:boolean-sequences} is considered in the context of
pseudorandom sequences and FCSRs. The main result is the calculated 2-adic
valuation of $f$-filtered bent sequences generated by the Maiorana-McFarland
class of Boolean functions.
\par In Section~\ref{sec:boolean-functions}, Boolean
functions are first introduced, and the section concludes with the definition of
the Walsh transform and bent functions. In Section~\ref{sec:n-adic-ring}, the
$N$-adic ring is defined and a few properties of $2$-adic sequences are
discussed. The $2$-adic valuation defined in this section is critical to
understanding the main result in Section~\ref{sec:boolean-sequences}. Section
\ref{sec:shift-registers} defines the FCSR following a fundamental discussion on
finite state machines and $n$-state shift registers. Two shift register
synthesis algorithms are given to demonstrate the necessity of adding a
non-linear component to an FCSR before using it as a secure stream cipher. Finally,
Section~\ref{sec:boolean-sequences} defines what this paper calls {\it
$f$-filtered Boolean sequences} and proves the main result on the $2$-adic
valuation of bent sequences generated by the functions in the Maiorana-McFarland
class.
\par Most of the examples in this paper are shown using {\ttfamily Sage v4.8}.
Methods for the examples are from the class {\ttfamily
sage.crypto.boolean\_functions} which comes with the current version of
{\ttfamily Sage}. In addition, the script {\ttfamily afsr.sage} is attached for
using many of the custom functions written for this paper. This script is
available at \url{https://github.com/celerier/oslo/blob/master/sage/afsr.sage}\,.
