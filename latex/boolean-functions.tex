\section{Boolean Functions}\label{sec:boolean-functions}
\par This section will establish the definition of a Boolean function
and how to write these functions as polynomials. The goal is to introduce the
Walsh transform, and important tools used in cryptography. The Walsh transform
measures the non-linearity of a Boolean function. This section concludes with
the definition of bent functions which in terms of the Walsh transform are
``perfectly non-linear'' Boolean functions. The definitions and
notations will follow those found in \cite{bk:cs09}.

\subsection{Review of Boolean Functions}
\par The two element field $(\gftwo,\oplus,\cdot)$ is the set $\{0,1\}$
with defined binary operations $\oplus$ and $\cdot$, also commonly referred
to as the logical {\em XOR} and {\em AND} operators respectively.
\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    XOR&AND\\
    \hline
    $0\oplus0:=0$&$0\cdot0:=0$\\
    $0\oplus1:=1$&$0\cdot1:=0$\\
    $1\oplus0:=1$&$1\cdot0:=0$\\
    $1\oplus1:=0$&$1\cdot1:=1$\\
    \hline
  \end{tabular}
  \caption{Binary Operations for $\gftwo$}
  \label{tab:GF(2)}
\end{table}
\par It should be clear that $(\gftwo,\oplus,\cdot)$ is a commutative ring
with an identity. Additionally, the only non-zero element $1$ is its own
inverse. In fact, $(\gftwo,\oplus,\cdot)$ is a finite field, which will now
be denoted by $\gftwo$. The $n$-dimensional vector space over $\gftwo$ will
be denoted by $\gftwo^n$, with the usual inner product. Components of vectors in
$\gftwo^n$ will be known as {\em bits}.
For two vectors $x,y\in\gftwo^n$ where $x=(x_0,\dots,x_{n-1})$ and
$y=(y_0,\dots,y_{n-1})$, the inner product in $\gftwo^n$ will be defined
as $x\cdot y:=\allowbreak x_0\cdot y_0 \oplus\allowbreak
\cdots \oplus\allowbreak x_{n-1}\cdot y_{n-1}$.

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^3
    sage: a=V([1,0,1]); b=V([0,1,1]);
    sage: a+b
    (1, 1, 0)
    sage: a.dot_product(b)
    1
  \end{lstlisting}
%  Let $a,b\in\gftwo^3$ such that $a=(1,0,1)$ and $b=(0,1,1)$ then
%  \begin{align*}
%    a+b      &=(1\oplus0,0\oplus1,1\oplus1)=(1,1,0) \\
%    a\cdot b &=1\cdot0\oplus0\cdot1\oplus1\cdot1=1
%  \end{align*}
\end{example}

\par Each vector in $\gftwo^n$ can be uniquely represented by an integer
between $0$ and $2^n-1$. To do this, the components of each vector in
$\gftwo^n$ are trivially mapped to the integers 0 and 1, and then used in
the one-to-one binary representation function $B$:
\begin{equation}
  B:\gftwo^n\rightarrow\{0,\dots,n-1\}\ \allowbreak
  {\rm such\ that }\ \allowbreak B(u) := \sum_{i=0}^{n-1}u_i\cdot2^i.
\end{equation}

\par If we define the vectors $v_i\in\gftwo^n$ by $v_i=B^{-1}(i)$
for $0\leq i\leq2^{n-1}$, then the sequence $(v_0,v_1,\allowbreak \dots,
\allowbreak v_{2^n-1})$ is said to be in {\em binary order}. This
ordering is the standard ordering used by Sage to list vectors in $\gftwo^n$.

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^3
    sage: V.list()
    [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1, 1)]
    sage: [GFn_to_integer(v) for v in V]
    [0, 1, 2, 3, 4, 5, 6, 7]
  \end{lstlisting}
\end{example}

\par This definition of $B$ has created the convention where the
{\em least significant bit} appears on the left and the 
{\em most significant bit} appears on the right. The {\it Hamming weight}
and {\it Hamming distance} functions are used to count the number of 1s in a
vector and count the number of differences between two vectors in
$\gftwo^n$. These are fundmental functions in coding theory and are useful
when talking about Boolean functions.

\begin{definition}\label{def:Hamming}
  Let $x,y\in\gftwo^n$. Then $wt:\gftwo^n\rightarrow\{0,\dots,n-1\}$
  is defined by
  \[
    {\rm wt}(x):=\sum_{i=0}^{n-1}x_i
  \]
  and $d:\gftwo^n\times\gftwo^n\rightarrow\{0,\dots,n-1\}$ is defined by
  \[
    d(x,y):={\rm wt}(x+y).
  \]
  Then ${\rm wt}(x)$ is the {\em Hamming\ weight} of $x$ and $d(x,y)$ is the
  {\em Hamming\ distance} between $x$ and $y$.
\end{definition}

\begin{definition}
\label{def:support}
  Let $x\in\gftwo^n$. Then ${\rm supp}:\gftwo^n\rightarrow\allowbreak
  2^{\{0,\dots,n-1\}}$ is defined by
  \[
    {\rm supp}(x):=\{i\in\{0,\dots,n-1\}:x_i=1\}
  \]
\end{definition}

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^5
    sage: a=V([0,1,1,0,1]); b=V([0,0,1,1,0])
    sage: Hamming_weight(a)
    3
    sage: Hamming_weight(b)
    2
    sage: a.support()
    [1, 2, 4]
    sage: b.support()
    [2, 3]
    sage: Hamming_weight(a+b)
    3
  \end{lstlisting}

%  Let $a,b,c\in\gftwo^5$ such that
%  \[
%  a=(0,1,1,0,1),\ b=(1,1,1,0,0),\ {\rm and}\ c=(0,0,1,1,0).
%  \]
%  Then,
%  \begin{center}
%    \begin{tabular}{c c c}
%      ${\rm wt}(a)=3$&${\rm supp}(a)=\{1,2,4\}$&$d(a,b)=2$\\
%      ${\rm wt}(b)=3$&${\rm supp}(b)=\{0,1,2\}$&$d(a,c)=3$\\
%      ${\rm wt}(c)=2$&$ {\rm supp}(c)=\{2,3\}$ &$d(b,c)=3$.\\
%    \end{tabular}
%  \end{center}
\end{example}

\par There is an interesting orthogonality property in the vector space
$\gftwo^n$ known as the {\em orthogonality principle} that every non-zero
vector in $\gftwo^n$ is orthogonal to exactly half of the vectors in the
vector space.

\begin{proposition}
\label{prop:orthogonality-principle}
  Let $x\in\gftwo^n$. Then
  \begin{equation*}
    \sum_{y\in\gftwo^n}(-1)^{x\cdot y}=
    \begin{cases}
      2^n \text{ \rm for } x=0, \\
      0 \text{ \rm otherwise.}
    \end{cases}
  \end{equation*}
\end{proposition}

\begin{proof}
  Let $x=0\in\gftwo^n$. Then $\forall y\in\gftwo^n$, $x\cdot y=0$, so
  $(-1)^{x\cdot y}=1$. Therefore, $\sum_{y\in\gftwo^n}(-1)^{x\cdot y}=
  \allowbreak\lvert\gftwo^n\rvert=\allowbreak 2^n$. \\

  Let $x\in\gftwo^n$ where $x\not=0$. Assume the $i$th bit of $x$ is
  non-zero and define $e_i\in\gftwo^n$ as a vector with all zero bits
  except for the $i$th bit which is $1$. Then
  \begin{align*}
    \sum_{y\in\gftwo^n}(-1)^{x\cdot y}
      &= \sum_{y\in\gftwo^n}(-1)^{x\cdot (y+e_i)} \\
      &= \sum_{y\in\gftwo^n}(-1)^{x\cdot y}(-1)^{x\cdot e_i} \\
      &= -\sum_{y\in\gftwo^n}(-1)^{x\cdot y}.
  \end{align*}
  Therefore, $\sum_{y\in\gftwo^n}(-1)^{x\cdot y}=\allowbreak
  -\sum_{y\in\gftwo^n}(-1)^{x\cdot y}$, which implies
  \[
  \sum_{y\in\gftwo^n}(-1)^{x\cdot y}=0.
  \]
\end{proof}

\begin{example}
  \ 
  \begin{lstlisting}
    sage: V=GF(2)^6
    sage: [sum([(-1)^(x.dot_product(y)) for y in V]) for x in V]
    [64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  \end{lstlisting}
\end{example}

\par When introduced to a new vector space, it is natural to begin looking
at functions in that field. The particular functions of interest here will
be what are known as {\em Boolean functions}.

\begin{definition}
\label{def:boolean-function}
  Any function $f$ defined such that 
  \begin{equation*}
    f:\gftwo^n\rightarrow\gftwo
  \end{equation*}
  is a {\em Boolean function}. The set of all Boolean functions on $n$
  variables will be denoted by $\BF_n$.
\end{definition}

\par The number of Boolean functions increases extremely rapidly as the
number of variables increases.\footnote{With today's fastest supercomputer
operating at 10.51 petaflops (the K computer in Japan), if one floating
point operation was expended visiting every Boolean function of 7 variables,
it would take over a thousand trillion years to complete the process. This
length of time is roughly 70,000 times the age of the universe. Though
every symmetric cryptosystem in use can be broken down into several Boolean
functions of several variables, it would be infeasible to brute force search
through all of the possibilities of Boolean functions which reconstruct the
cryptosystem.}

\begin{equation}
  \lvert\BF_n\rvert = 2^{2^n}
\end{equation}

\par The Boolean function $f$ is presented in a {\em truth\ table} in 
Table \ref{tab:truth-table}. The Hamming weight of $f$ is the number of 1s
that $f$ has when evaluated at every point in the $\gftwo^n$: 
\[
{\rm wt}(f)=\lvert\{u\in\gftwo^n:f(u)=1\}\rvert.
\]
\begin{table}
  \centering
  \begin{tabular}{|c|c|c|c||c|}
    \hline
    $x_0$&$x_1$&$x_2$&$x_3$&$f(x_0,x_1,x_2,x_3)$\\
    \hline
    0&0&0&0&0\\
    1&0&0&0&1\\
    0&1&0&0&1\\
    1&1&0&0&0\\
    0&0&1&0&1\\
    1&0&1&0&0\\
    0&1&1&0&1\\
    1&1&1&0&0\\
    0&0&0&1&0\\
    1&0&0&1&0\\
    0&1&0&1&1\\
    1&1&0&1&0\\
    0&0&1&1&0\\
    1&0&1&1&0\\
    0&1&1&1&1\\
    1&1&1&1&1\\
    \hline
  \end{tabular}
  \caption{Truth Table of $f$}
  \label{tab:truth-table}
\end{table}

\subsection{Boolean Polynomials}
\par A truth table is not a very compact method to define a Boolean
function. It is much more efficient and easier to implement a Boolean
function when written as a formula. This can be done by writing a Boolean
function algebraically. As a first step toward defining $f$ algebraically a
one-to-one and onto function will be defined which maps every $f$ in
$\BF_n$ to a vector in $\gftwo^{2^n}$. This will be the function
$V:\BF_n\rightarrow\gftwo^{2^n}$ such that
\begin{equation}\label{eqn:bool-vector}
  V(f)
    :=(f(v_0),\dots,f(v_{2^n-1}))\ {\rm where\ } v_i=B^{-1}(i).
\end{equation}
It is trivial to show that addition is homomorphic under $V$,
\[
V(f_1\oplus f_2)=V(f_1)\oplus V(f_2).
\]
Then the standard basis of $\gftwo^{2^n}$ can be used to pull back to an
equivalent basis of $\BF_n$. Let $e_i\in\gftwo^{2^n}$ be defined so that
\begin{align*}
  e_0&=(1,0,\dots)\\
  e_1&=(0,1,\dots)\\
  \vdots \\
  e_{2^n-1}&=(0,\dots,0,1).
\end{align*}
\par The {\em atomic Boolean functions} will be defined as the
$f_i\in\BF_n$ where there exists an $e_i\in\gftwo^{2^n}$ such that
$V(f_i)=e_i$. Every vector of $\gftwo^{2^n}$ can be written as a linear
combination of the standard basis vectors, and equivalently, every Boolean
function is a linear combination of atomic Boolean functions. This means
for every $u\in\gftwo^{2^n}$ there exists a set of $c_i\in\gftwo$ such that
\begin{align*}
  u  &=c_0e_0\oplus\cdots\oplus c_{2^n-1}e_{2^n-1} \\
  \Leftrightarrow f &=c_0f_0\oplus\cdots\oplus c_{2^n-1}f_{2^n-1}.\\
\end{align*}
where $V(f)=u$.

\par The function $f$ defined in Table \ref{tab:truth-table} can be written
as a linear combination of the atomic Boolean functions in $\BF_4$. Since
the coefficients in the linear combinations are either 0 or 1, it is true
that every Boolean function can be written as the sum of ${\rm wt}(f)$ atomic
Boolean functions.
\begin{table}[h!]
  \centering
  \begin{tabular}{|c|c|c|c||c|c|c|c|c|c|c|c|}
    \hline
    $x_0$&$x_1$&$x_2$&$x_3$
      &$f$&$f_1$&$f_2$&$f_4$&$f_6$&$f_{10}$&$f_{14}$&$f_{15}$\\
    \hline
    0&0&0&0&0&0&0&0&0&0&0&0\\
    1&0&0&0&1&1&0&0&0&0&0&0\\
    0&1&0&0&1&0&1&0&0&0&0&0\\
    1&1&0&0&0&0&0&0&0&0&0&0\\
    0&0&1&0&1&0&0&1&0&0&0&0\\
    1&0&1&0&0&0&0&0&0&0&0&0\\
    0&1&1&0&1&0&0&0&1&0&0&0\\
    1&1&1&0&0&0&0&0&0&0&0&0\\
    0&0&0&1&0&0&0&0&0&0&0&0\\
    1&0&0&1&0&0&0&0&0&0&0&0\\
    0&1&0&1&1&0&0&0&0&1&0&0\\
    1&1&0&1&0&0&0&0&0&0&0&0\\
    0&0&1&1&0&0&0&0&0&0&0&0\\
    1&0&1&1&0&0&0&0&0&0&0&0\\
    0&1&1&1&1&0&0&0&0&0&1&0\\
    1&1&1&1&1&0&0&0&0&0&0&1\\
    \hline
  \end{tabular}
  \caption{$f$ broken into atomic Boolean function in $\BF_4$}
  \label{tab:atomic-f}
\end{table}
\par The equation $f=f_1+f_2+f_4+f_6+f_{10}+f_{14}+f_{15}$ should be clear
from Table \ref{tab:atomic-f}. Knowing how to write the atomic Boolean
functions as polynomials would lead to knowing how to write any Boolean
function as a polynomial. The polynomials representing the Boolean functions
will belong to the the polynomial ring $\gftwo[x_0,\dots,x_{n-1}]/
(x_0^2\oplus x_0,\dots,x_{n-1}^2\oplus x_{n-1})$. To properly represent
an atomic Boolean function, a polynomial must equal 1 at only one vector
$(x_0,\dots,x_{n-1})$. Recall the support function from Definition
\ref{def:support}. Then the polynomial respresenting each Boolean function
is as follows:
\begin{equation}\label{eqn:atomic-ANF}
  f_i=\bigg(\prod_{j\in {\rm supp}(B^{-1}(i))}x_j\bigg)
    \bigg(\prod_{j\not\in {\rm supp}(B^{-1}(i))}(1\oplus x_j)\bigg).
\end{equation}
\begin{proof}
  Let $x=B^{-1}(i)$ where $x=(x_0,\dots,x_{n-1})$. Then
  $\{x_i:x_i=1\}=\{x_i:i\in {\rm supp}(x)\}$. Therefore,
  \[
  f_i(x)=\bigg(\prod_{j\in {\rm supp}(B^{-1}(i))}x_j\bigg)
    \bigg(\prod_{j\not\in {\rm supp}(B^{-1}(i))}(1\oplus x_j)\bigg)=1.
  \]

  Let $x\not=B^{-1}(i)$. Then,
  \[
  \bigg(\prod_{j\in {\rm supp}(B^{-1}(i))}x_j\bigg)=0
  \]\[
  \therefore f_i(x)=0.
  \]
\end{proof}

\par Now the function $f$ from Table \ref{tab:truth-table} can be written as
the sum of the following atomic polynomials:
\begin{align*}
  f_1   &=(1\oplus x_3)(1\oplus x_2)(1\oplus x_1)x_0\\
        &=x_0 \oplus x_1x_0 \oplus x_2x_0 \oplus x_2x_1x_0 \oplus
          x_3x_0 \oplus x_3x_1x_0 \oplus x_3x_2x_0 \oplus x_3x_2x_1x_0\\
  f_2   &=(1\oplus x_3)(1\oplus x_2)x_1(1\oplus x_0)\\
  f_4   &=(1\oplus x_3)x_2(1\oplus x_1)(1\oplus x_0)\\
  f_6   &=(1\oplus x_3)x_2x_1(1\oplus x_0)\\
  f_{10}&=x_3(1\oplus x_2)x_1(1\oplus x_0)\\
  f_{14}&=x_3x_2x_1(1\oplus x_0)\\
  f_{15}&=x_3x_2x_1x_0
\end{align*}
\par After summing the atomic polynomials upon multiplying them out,
\[
  f=x_0x_1x_2x_3\oplus x_0x_1x_3 \oplus x_0x_3 \oplus x_0 \oplus x_1x_2x_3
    \oplus x_1x_2\oplus x_1\oplus x_2x_3 \oplus x_2.
\]
This result is easily verified in Sage:
\begin{lstlisting}[gobble=1]
  sage: f=BooleanFunction([0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1])
  sage: f.algebraic_normal_form()
  x0*x1*x2*x3 + x0*x1*x3 + x0*x3 + x0 + x1*x2*x3 + x1*x2 + x1 + x2*x3 + x2
\end{lstlisting}

\par Now the uniqueness of the polynomial representation for each Boolean
function is considered. This is easily seen by considering the uniqueness of
each Boolean function and the size of the polynomial ring.

\begin{theorem}
Each $n$-variable Boolean function is uniquely represeneted as a polynomial
in the polynomial ring $\gftwo[x_0,\dots,x_{n-1}]/ (x_0^2\oplus x_0,\dots,
x_{n-1}^2 \oplus x_{n-1})$. Let $f\in\BF_n$. Then there exists a unique set
of $a_I\in\gftwo$, $I\in2^{\{0,\dots,n-1\}}$, such that
\begin{equation}\label{eqn:ANF}
  f(x)=\sum_{I\in2^{\{0,\dots,n-1\}}}a_I\bigg(\prod_{i\in I}x_i\bigg)
\end{equation}
\end{theorem}

\begin{proof}
  \begin{align*}
  \lvert\BF_n\rvert
    &= \lvert \gftwo^{2^n} \rvert \\
    &= \lvert \{(a_{\emptyset},\ldots,a_I,\ldots):a_I\in\gftwo\} \rvert \\
    &= \lvert \gftwo[x_0,\dots,x_{n-1}]/ (x_0^2\oplus x_0,\dots,
    x_{n-1}^2 \oplus x_{n-1})\rvert
  \end{align*}
  Because every Boolean function is determined by at least one polynomial
  and the size of the polynomial ring equals the size of the set of all
  Boolean functions, each Boolean function must be uniquely determined by a
  polynomial in the polynomial ring.
\end{proof}

\subsection{The Walsh Transform}
\par The Walsh transform measures the non-linearity of a Boolean function by
determining the distance between a given Boolean function $f(x)$ and a linear
function $\lambda\cdot x$. The Walsh transform is similar to the discrete
Fourier transform and is in fact used to obtain the Fourier coefficients for a
Boolean function. For this paper, the Walsh transform is considered over the
discrete Fourier transform because this is the transformation used by Rothaus
in his original definition of bent functions published in the Journal of
Combinatorial Theory in 1976 \cite{art:r76}. The definitions in this section
follow \cite{bk:lsy11}.

\begin{definition}
  A {\em character} $\Chi$ of a finite abelian group $G$ is a group
  homomorphism from $G$ into the multiplicative group of complex numbers.
\end{definition}

For the purposes of this paper, it should be clear that
$\Chi_\lambda(x):=(-1)^{\lambda\cdot x}$ where $\lambda,x\in\gftwo^n$ is a
{\em group\ character} of $\gftwo^n$. Define the {\em dual\ group}
$\hat{\gftwo^n}$ to be the group of all characters of $\gftwo^n$. The group
operation
in $\hat{\gftwo^n}$ is pointwise multiplication of functions:
\[
(\Chi\cdot\psi)(x)=\Chi(x)\psi(x),\ x\in\gftwo^n.
\]
This operation is closed under multiplication.

\begin{lemma}\label{lem:dual}
  $\gftwo^n\cong\hat{\gftwo^n}$
\end{lemma}

\begin{proof}
  \par Let $\Upsilon:\gftwo^n\rightarrow\hat{\gftwo^n}$ where
  $\Upsilon(\lambda):=\Chi_\lambda$.
  Every character in $\hat{\gftwo^n}$ corresponds to an element of
  $\gftwo^n$. Thus, $\lvert\gftwo^n\rvert=\lvert\hat{\gftwo^n}\rvert$.
  Therefore if $\Upsilon$ is one-to-one, then it must be an isomorphism.\\
  Let $\Upsilon(\lambda_1)=\Upsilon(\lambda_2)$. Then for all $x$
  \begin{align*}
    (-1)^{\lambda_1\cdot x}
      &=(-1)^{\lambda_2\cdot x}\\
      &=(-1)^{(\lambda_1+\lambda_1+\lambda_2)\cdot x}\\
      &=(-1)^{\lambda_1\cdot x}(-1)^{(\lambda_1+\lambda_2)\cdot x}.
  \end{align*}
  Finally, $(\lambda_1+\lambda_2)\cdot x=0$ for all $x\in\gftwo^n$, which
  implies $\lambda_1+\lambda_2=0$. Therefore, $\lambda_1=\lambda_2$.
\end{proof}

\par Addition in $\gftwo^n$ corresponds to multiplication in
$\hat{\gftwo^n}$. By definition
\[
(\Chi_{\lambda_1}\cdot\Chi_{\lambda_2})(x)
  =\Chi_{\lambda_1}(x)\Chi_{\lambda_2}(x)
  =(-1)^{\lambda_1\cdot x}(-1)^{\lambda_2\cdot x}
  =(-1)^{(\lambda_1+\lambda_2)\cdot x}
  =\Chi_{\lambda_1+\lambda_2}(x).
\]

\par It is clear from the proof of Lemma \ref{lem:dual} that all the characters
of $\gftwo^n$ correspond to all of the linear functions in $\BF_n$.

\begin{definition}\label{def:pBF}
  Let $f\in\BF_n$. Then $\hat{f}:\gftwo^n\rightarrow\rrr$ such that
  $\hat{f}(x)=(-1)^{f(x)}$ is a \textit{pseudo-Boolean function}. The set of all
  pseudo Boolean functions is denoted $\hat{\BF}_n=\{\hat{f}:f\in\BF_n\}$.
\end{definition}
\begin{lemma}\label{lem:characters}
\par Every character $\Chi_\lambda$ belongs to $\hat{\BF_n}$.
\end{lemma}
\begin{proof}
  \par This is trivially true.
\end{proof}
\begin{lemma}
  If \[W={\rm span}_\rrr(\hat{\BF}_n)=\left\{\sum_{i\in I}a_i\hat{f}_i:
  \hat{f}_i\in\hat{\BF}_n{\rm ,\ }a_i\in\rrr{\rm ,\ and\ }|I|<\infty\right\},\]
  then the $\hat{\gftwo^n}$ forms an orthonormal basis of $W$.
\end{lemma}
\begin{proof}
  The atomic Boolean functions correspond to a basis of $W$. Thus, the dimension
  of $\hat{\BF_n}$ is at most $2^n$. The $2^n$ characters of $\gftwo^n$
  are elements of $\hat{\BF}_n$, by Lemma \ref{lem:characters}.
  \begin{align*}
    \sum_{x\in\gftwo^n}{\Chi_{\lambda_i}(x)\cdot\Chi_{\lambda_j}(x)}
    &=\sum_{x\in\gftwo^n}
      {(-1)^{(\lambda_i+\lambda_j)\cdot x}}\\
    &=\begin{cases}
      0 & \text{if } i\not=j \\
      2^n & \text{if } i=j.
    \end{cases}
  \end{align*}
  Therefore, the characters of $\gftwo^n$ are orthonormal in $W$. Since the
  dimension of $W$ is at most $2^n$, and there are $2^n$ characters,
  $\hat{\gftwo^n}$ forms an orthonormal basis of $W$.
\end{proof}

%\begin{definition}\label{def:DFT}
% The {\em discrete\ Fourier\ transform} or DFT of a Boolean function is
%  defined by
% \begin{equation}\label{eqn:DFT}
%    \mathcal{F}f(\lambda)
%      =\sum_{x\in\gftwo^n}f(x)\Chi_\lambda(x)
% \end{equation}
%\end{definition}

\begin{definition}\label{def:walsh}
  Let $f\in\BF_n$ and $\lambda\in\gftwo^n$. Then the {\em Walsh transform}
  of $f$ is defined by:
  \begin{equation}\label{eqn:walsh}
    \mathcal{W}_f(\lambda)=\sum_{x\in\gftwo^n}\hat{f}(x)\Chi_\lambda(x).
  \end{equation}
  Let
  \[
    \mathcal{W}(f)=(\mathcal{W}_f(\lambda_0),\dots,\mathcal{W}_f(\lambda_{2^n-1})),
  \]
  where $\lambda_i=B^{-1}(i)$, be the {\it Walsh spectrum} of $f$.
\end{definition}

\begin{example}
\par Here are some examples of the Walsh spectrums of different Boolean
functions:
  \begin{lstlisting}
    sage: f0=BooleanFunction([0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1])
    sage: f0.walsh_hadamard_transform()
    (-2, 6, -6, -6, -2, -2, 2, -6, 2, 2, 6, -2, 2, -6, -2, -2)
    sage: f0.algebraic_normal_form( )
    x0*x1*x2*x3 + x0*x1*x3 + x0*x3 + x0 + x1*x2*x3 + x1*x2 + x1 + x2*x3 + x2
    sage:
    sage: f1=BooleanFunction([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0])
    sage: f1.walsh_hadamard_transform()
    (0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    sage: f1.algebraic_normal_form()
    x0 + 1
    sage:
    sage: f2=BooleanFunction([1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1])
    sage: f2.walsh_hadamard_transform()
    (0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    sage: f2.algebraic_normal_form()
    x0 + x1 + 1
    sage:
    sage: f3=BooleanFunction([1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1])
    sage: f3.walsh_hadamard_transform()
    (2, 2, -2, 14, -2, -2, 2, 2, -2, -2, 2, 2, 2, 2, -2, -2)
    sage: f3.algebraic_normal_form( )
    x0*x1*x2*x3 + x0 + x1*x2*x3 + x1 + 1
  \end{lstlisting}
\end{example}

\par 
\par Every pseudo-Boolean function can be written as a linear combination of
the characters of $\gftwo^n$. The coefficients in these linear combinations
reveal important properties of the functions. Rothaus rewrote the
pseudo-Boolean function as a linear combination of characters
as follows \cite{art:r76}. 

\begin{lemma}
  For $\hat{f}\in\hat{\BF}_n$,
\begin{equation}\label{eqn:rewrite-pseudo}
  \hat{f}(x)
    =\frac{1}{2^{n/2}}
      \sum_{\lambda\in\gftwo^n}c(\lambda)\Chi_\lambda(x)
\end{equation}
  where $c(\lambda)$ are given by
  \begin{equation}\label{eqn:clambda}
    c(\lambda)=\frac{1}{2^{n/2}}\mathcal{W}_f(\lambda)
    %\mathcal{F}\hat{f}(\lambda).
    %=\frac{1}{2^{n/2}}\sum_{x\in\gftwo^n}(-1)^{f(x)+\lambda\cdot x}.
  \end{equation}
\end{lemma}

\par Each $c(\lambda)$ is called a \textit{Fourier coefficient} of $f$.
As observed by Rothaus in \cite{art:r76}, $2^{n/2}c(\lambda)$ is the
number of zeros minus the number of ones of the function
$f(x)+\lambda\cdot x$. The Hamming weight of $f$ is easily determined using
the zero Fourier coefficient $c(0)$:
\begin{align*}
  c(0)&=\frac{1}{2^{n/2}}\sum_{x\in\gftwo^n}(-1)^{f(x)}\\
  &=\frac{1}{2^{n/2}}\big((2^n-{\rm wt}(f))-{\rm wt}(f)\big)
\end{align*}
\begin{equation}
  \Rightarrow {\rm wt}(f)=2^{n-1}-2^{n/2-1}c(0).
\end{equation}

\begin{example}
  There are two cases that should be clear to the reader.
  \begin{enumerate}[1.]
    \item Let $f(x)=\lambda\cdot x$. Then $\mathcal{W}_f(\lambda)=2^n$.
    \item Let $f(x)\not=\lambda\cdot x \ \ \forall x$. Then $f(x)=
      \lambda\cdot x+1 \ \ \forall x$. So, $\mathcal{W}_f(\lambda)=-2^n$
  \end{enumerate}
  In both cases, $f$ is an affine function.
\end{example}

\par For large $|\mathcal{W}_f(\lambda)|$, the Hamming distance between $f$ and
an affine function in $\BF_n$ is small.

\subsection{Bent Functions}
\par These functions are useful in cryptographic applications because they
add resistance to differential attacks as a result of being ``perfectly
non-linear''. As mentioned before, these were defined by Rothaus in 1976. The main
result in Section \ref{sec:boolean-sequences} is given on bent functions because
of their important cryptographic property of being as far away as possible from
every affine function in $\BF_n$.

\begin{definition}
  If all of the Fourier coefficients of $\hat{f}$ are $\pm1$ then
  $f$ is a \textit{bent function}.
\end{definition}

\begin{proposition}{\rm \cite{art:r76}}
  If $f$ is a bent function on $\gftwo^n$, then $n$ is even, $n=2k$.
  Moreover,
  the degree of $f$ is at most $k$, except in the case $k=1$.
\end{proposition}
\begin{proof}
  \par $c(\lambda)=\pm1$. This implies $2^{n/2}c(\lambda)$ is an
  integer. Therefore $n$ must be even.
  \par Let $n=2k$ with $k>1$, and let $r>k$. Consider the polynomial
  $f(x,\allowbreak 0,0,\dots,0)=\allowbreak g(x)$ where $x=(x_1,x_2,\dots,x_r)$
  (up to this point all indexing has
  started at 0; it is more convenient in this proof to begin numbering at
  1). Then by Equation~(\ref{eqn:rewrite-pseudo}),
  \[
  \hat{g}(x)=\frac{1}{2^{r/2}}\sum_{\lambda_1,\lambda_2,\dots,\lambda_r=0,1}
    b(\lambda_1,\dots,\lambda_r)\Chi_{(\lambda_1,\ldots,\lambda_r)}(x)
  \]
  and
  \[
  \hat{f}(x,0)=\frac{1}{2^{n/2}}
    \sum_{\lambda_1,\lambda_2,\dots,\lambda_n=0,1}
    c(\lambda_1,\dots,\lambda_n)\Chi_{(\lambda_1,\ldots,\lambda_n)}(x,0).
  \]
  Because $f(x,0)=g(x)$ and the uniqueness of the Fourier expansion, $b$ and
  $c$ are related such that
  \[
  b(\lambda_1,\dots,\lambda_r)
    =\frac{1}{2^{(n-r)/2}}\sum_{\lambda_{r+1},\dots,\lambda_n=0,1}
    c(\lambda_1,\dots,\lambda_r,\lambda_{r+1},\dots,\lambda_n).
  \]
  \par Then,
  \begin{align*}
  {\rm wt}(f(x,0))&={\rm wt}(g(x))\\
    &=2^{r-1}-2^{r/2-1}b(0)\\
    &=2^{r-1}-2^{r-n/2-1}\sum_{\lambda_{r+1},\dots,\lambda_n=0,1}
      c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n).
  \end{align*}
  \par There are $2^{n-r}$ summands in
  $\sum{c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n)}.$ Since $f$ is bent,
  $c(\lambda)=\pm1$. By rewriting $1=-1+2$,
  \begin{align*}
    \sum{c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n)}
      &=-2^{n-r}+2{\rm wt}(c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n))\\
      &=2\big({\rm wt}(c(0,\dots,0,\lambda_{r+1},\dots,\lambda_n))-2^{n-r-1}\big)
  \end{align*}
  \par Thus, ${\rm wt}(g(x))$ is even. This implies that $g(x)$ is the sum of an
  even number of atomic Boolean functions. Therefore the coefficient of
  $x_1x_2\cdots x_r$ in the polynomial representing $g(x)$ must be 0. This
  is true for every $r>k$, so the degree of $f$ must not be greater than
  $k$.
\end{proof}

% Strict Avalanche Criterion
% directional derivatives
% equivalent definition of a bent function

\par The set of all bent functions is not known. There however are a few basic
constructions which are known. The Rothaus construction and Maiorana-McFarland class of Boolean
functions are presented here as two of the known constructions for bent
functions.

\subsubsection{Rothaus Construction of Bent Functions}
\par In one of the first papers written about bent functions, Rothaus identified
two large general classes of bent function on $\BF_n$, $n=2k$. The simpler of
the two is presented here:
\begin{proposition}
  Let $n$ be even, $x_1,y_1,\dots,x_k,y_k$ be independent variables, and
  $P(x)\in\BF_{n/2}$ (so $P(x)$ is a function $n/2$ variables). Then the polynomial
  $Q(x,y)\in\BF_{n}$ given by
  \begin{equation}
    Q(x,y)=x_1y_1+x_2y_2+\cdots+x_ky_k+P(x)
  \end{equation}
  is bent.
\end{proposition}
\par The proof that this function is bent can be found in Rothaus' paper
\cite{art:r76}.

\begin{example}
  \par Both $f$ and $g$ in this example are bent according to Rothaus.
  \begin{lstlisting}
    sage: B=BooleanPolynomialRing(6,'x')
    sage: B.inject_variables(verbose=false)
    sage: f=BooleanFunction(x0*x1+x2*x3+x4*x5)
    sage: f.truth_table(format='int')
    (0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0,
    0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1,
    1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1)
    sage: f.is_bent()
    True
    sage: g=f+BooleanFunction(x0*x2+x0)
    sage: g.truth_table(format='int')
    (0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
    0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1,
    1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1)
    sage: g.is_bent()
    True
  \end{lstlisting}
\end{example}
\subsubsection{Maiorana-McFarland Class Construction of Bent Functions}
\par The Maiorana-McFarland class (or M-M class) of Boolean functions is a
generalized Rothaus construction of bent functions. It uses a
permutation function $\pi$ on half of the input variables to each function.

\begin{definition}
  Let $\pi:\gftwo^k\rightarrow\gftwo^k$ be the linear transformation on
  $\gftwo^n$ represented by the matrix $\pi\in M_{k\times k}(\gftwo)$ such that the
  matrix $\pi$ has exactly $k$ non-zero entries arranged so that every row
  and column has exactly one non-zero entry. Then $\pi$ is a
  {\it permutation matrix}.
\end{definition}

\begin{example}
  \ 
  \begin{lstlisting}
    sage: pi0=matrix(GF(2),[[0,0,1],[1,0,0],[0,1,0]])
    sage: pi0
    [0 0 1]
    [1 0 0]
    [0 1 0]
    sage: V=GF(2)^3
    sage: x=V([0,1,1]); y=V([1,0,0])
    sage: (matrix(x)).transpose()
    [0]
    [1]
    [1]
    sage: pi0*(matrix(x)).transpose()
    [1]
    [0]
    [1]
    sage: (matrix(y)).transpose(
    [1]
    [0]
    [0]
    sage: pi0*(matrix(y)).transpose( )
    [0]
    [1]
    [0]
  \end{lstlisting}
\end{example}

\par For every permutation function $\pi$ on $\gftwo^k$ the {\it component permutation
function} $\bar{\pi}$ can defined such that for $0 \leq i \leq k-1$,
\[
\bar{\pi}(i)=j \text{ where } \pi(e_i)=e_j \text{ for basis vectors } e_i,
e_j\in\gftwo^k.
\]

\begin{example}
  If $\pi_0=\begin{bmatrix}
               0&0&1\\
               1&0&0\\
               0&1&0\\
             \end{bmatrix}$ and $\pi_1=
             \begin{bmatrix}
               0&1&0\\
               1&0&0\\
               0&0&1\\
             \end{bmatrix}$, then $\bar{\pi}_0$ is the permutation cycle $(0\,1\,2)$
             and $\bar{\pi}_1$ is the permutation cycle $(0\,1)(2)$.
\end{example}
\par A simple bent function construction is accomplished by using permutations
like the ones defined here. These Boolean functions belong to the {\it
Maiorana-McFarland original class}. This is the set
$\mathcal{M}$ which contains all Boolean functions on
$\gftwo^n=\{(x,y)=(x_0,\dots,x_{n-1},y_0,\dots,y_{n-1}):x,y\in\gftwo^{n/2}\}$, of the form
  \[
  f(x,y)=x\cdot\pi(y)\oplus g(y)
  \]
where $\pi$ is any permutation on $\gftwo^{n/2}$ and $g$ is any Boolean
function on $\gftwo^{n/2}$.

\begin{proposition}{\rm\cite{col:c06}}
\par All functions in the Maiorana-McFarland class of Boolean functions are
bent.
\end{proposition}
\par The proof of these functions being bent can be found in \cite{col:c06}.


\begin{example}
  \par Both $f$ and $g$ in this example are in the Maiorana-McFarland class of
  Boolean functions.
  \begin{lstlisting}
    sage: f=BooleanFunction(x0*x4+x1*x3+x2*x5)
    sage: f.truth_table(format='int')
    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
    1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1,
    0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1)
    sage: f.is_bent()
    True
    sage: g=f+BooleanFunction(x0*x2+x0)
    sage: g.is_bent()
    True
  \end{lstlisting}
\end{example}
