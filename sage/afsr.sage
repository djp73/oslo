"""
Algebraic feedback shift register sequences,
N-adic sequences and bent functions. Also, this includes
some examples of usage of the sage.crypto.boolean_function
module.


AUTHORS:
   David Joyner, wdjoyner@gmail.com
   Charles Celerier, charles.celerier@gmail.com
   copyright 2011

LICENSE:
   Modified BSD

last modified 2012-01-11
"""

def connection_element(Qs, p):
    """
    Input consists of 
        Qs - r+1 elements from T ("taps")
        p - prime

    This function returns the connection element

    EXAMPLES:
        sage: p = 5; Qs = [2,2,1,2]
        sage: connection_element(Qs, p)
        283

    """
    r = len(Qs)-1
    c = -Qs[0]+sum([Qs[i]*p**i for i in range(1,r+1)])
    return c


def generating_quotient(As, Qs, m, p):
    """
    Input consists of 
        S, T - complete sets of reps mod p
        As - r elements from S
        Qs - r+1 elements from T
        m - integer
        p - prime
        N - positive integer > r

    This function returns a rational whose p-adic expansion 
    agrees with As.

    EXAMPLES:
        sage: p = 5; Qs = [2,2,1,2]; As = [1,2,2]; m = 4
        sage: generating_quotient(As, Qs, m, p)
        -487/283
        sage: alpha = Qp(5)(-487/283)
        sage: alpha.padded_list(20)
        [1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 0, 0, 3, 0, 2, 0, 2, 4, 0, 0]

    This gives the same output as afsr does.

    """
    r = len(Qs)-1
    DS = sum([sum([Qs[i]*As[n-i]*p**n for i in range(1,n+1)]) for n in range(1,r)])
    u = -m*p**r - Qs[0]*sum([As[i]*p**i for i in range(r)]) + DS
    return u/connection_element(Qs, p)


def afsr(S, T, As, Qs, m, p, N):
    """
    Input consists of 
        S, T - complete sets of reps mod p
        As - r elements from S
        Qs - r+1 elements from T
        m - integer
        p - prime
        N - positive integer > r

    This function returns a list of length N generated
    by the AFSR associated to (S, T, As, Qs, m, p), as in [KX]
  
    EXAMPLES:
        sage: p = 5; N = 20; S = range(p); T = S
        sage: As = [1,2,2]; Qs = [1,2,1,2]; m = 4
        sage: afsr(S, T, As, Qs, m, p, N)
        [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
        sage: As = [1,2,2]; Qs = [2,2,1,2]; m = 4
        sage: afsr(S, T, As, Qs, m, p, N)
        [1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 0, 0, 3, 0, 2, 0, 2, 4, 0, 0]
        sage: Qp(5)(-487/283)
         1 + 2*5 + 2*5^2 + 5^3 + 5^5 + 5^7 + 2*5^8 + 3*5^12 + 2*5^14 + 2*5^16 + 4*5^17 + O(5^20)
        sage: alpha.padded_list(20)
        [1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 0, 0, 3, 0, 2, 0, 2, 4, 0, 0]
        sage: multiplicative_order(mod(5,283)) # the period
        282


    REFERENCE:
        [KX] Klapper and Xu, "Algebraic feedback shift registers",
             Theoretical Com. Sci., vol 226, 1999,
             http://www.cs.uky.edu/~klapper/papers.html

    """
    r = len(As)
    # test if S and T will work
    if len(S) <> p:
        raise NameError("arg S is not a complete set of reps mod ", p)
    if len(T) <> p:
        raise NameError("arg T is not a complete set of reps mod ", p)
    Zp = IntegerModRing(p)
    S0 = [Zp(s) for s in S]
    S0.sort()
    if S0 <> [Zp(x) for x in range(p)]:
        raise NameError("arg S is not a complete set of reps mod ", p)
    T0 = [Zp(t) for t in T]
    T0.sort()
    if T0 <> [Zp(x) for x in range(p)]:
        raise NameError("arg T is not a complete set of reps mod ", p)
    # test if As are in S
    for x in As:
        if not(x in S):
            raise NameError("arg As is not a set of fills for ", S)
    # test if Qs are in T
    for x in Qs:
        if not(x in T):
            raise NameError("arg Qs is not a set of taps for ", T)
    if len(Qs) <> r+1:
        raise NameError("arg Qs is not a set of taps for ", T)
    # force m to be an initial memory value
    m = ZZ(m)
    # force p to be a prime
    p = next_prime(p-1)
    # force N to be an integer
    N = ZZ(N)
    conn_elmt = -Qs[0]+sum([Qs[i]*p**i for i in range(1,r+1)])
    newAs = As
    new_m = m
    a = S[0]
    if N <= r:
        return As
    for j in range(N-r):
        tau = sum([Qs[i]*newAs[-i] for i in range(1,r+1)]) + new_m
        for s in S:
            if Zp(tau) == Zp(s*Qs[0]):
                newAs.append(s)
                new_m = ZZ((tau-s*Qs[0])/p)
                #print j, tau, s, new_m, r
    return newAs


def afsr2(u, q, p, N): 
    """
    Input consists of 
        u, q - positive integers (q<p^(20))
        p - positive integer
        N - positive integer > r

    This function returns a triple:
     -  u,q in least denominator form,
     -  a list of length N generated by the AFSR associated 
        to (u, q, p), as in Theorem 10, [KX])
  
    EXAMPLES:
        sage: u = 972; q = 1001; p = 5; N = 20
        sage: adic_seq(u, q, p, N)
        (972, 1001, [2, 4, 3, 1, 1, 4, 0, 4, 0, 3, 1, 3, 4, 1, 3, 2, 4, 2, 3, 3])
        sage: afsr2(u, q, p, N)
        (972, 1001, [2, 4, 3, 1, 1, 4, 0, 4, 0, 3, 1, 3, 4, 1, 3, 2, 4, 2, 3, 3])

    REFERENCE:
        [KX] Klapper and Xu, "Algebraic feedback shift registers",
             Theoretical Com. Sci., vol 226, 1999,
             http://www.cs.uky.edu/~klapper/papers.html

    """
    S = range(p)
    U = range(q)
    G = gcd(u,q)
    u = ZZ(u/G)
    q = ZZ(q/G)
    gamma = 1
    for i in U:
        if i*p%q==1:
            gamma = i
    rho = 1
    for i in S:
        if i*q%p==1:
            rho = i
    aseq=[];useq=[];j=0;
    useq+=[(u*gamma**k)%q-q for k in range(N)]
    while (u%(p**(j+1))==0 and  u>=0):
        aseq+=[0]
        j+=1
    aseq+=[rho*((u*gamma**j)%q)%p]
    aseq+=[rho*useq[k]%p for k in range(j+1,N)]
    return u,q,aseq

#######################################

def index(x,M):
    """
    Inputs a non-zero integer and outputs the 
    integer part of its log.

    """
    return int(log(abs(x))/log(M))

def height(x,y,M):
    """
    Inputs a pair of non-zero integers and outputs the 
    max of the integer part of their log base M.

    EXAMPLE:
        sage: height(32,33,2)
        5
    """
    return int(max(log(abs(x))/log(M),log(abs(y))/log(M)))

def interpolation_set(M):
    """
    Returns the interpolation set [1] associated to the 
    modulus M.

    Needed in rational_synthesis_xu.

    REFERENCE:
        [KX] Klapper and Xu, "Register Synthesis for Algebraic Feedback 
             Shift Registers Based on Non-Primes," (section 3)
             http://www.cs.uky.edu/~klapper/papers.html

    """
    if M==2:
        L = 5
    if M==3:
        L = 15
    if M>3:
        L = int(M**3/2)
    return range(-L,L+1)

def findst(h1,h2,i,M):
    """
    Solves h1*s+h2*t = 0 mod M^5.

    Needed in rational_synthesis_xu.

    """
    P = interpolation_set(M)
    for s in P:
        for t in P:
            if (s*h1+t*h2)%M**(i+5) == 0:
                return (s,t)

def maxpower(u,q,M):
    """
    Returns max power of M dividing u,q

    Needed in rational_synthesis_xu.

    EXAMPLES:
        sage: maxpower(1000, 200, 10)
        2
        sage: maxpower(1200,9,9)
        0


    """
    r = gcd(u,q)
    m = int(log(r,M))
    for t in range(2*m):
        if r%M**t != 0:
            return t-1
    return 0

def ifsinP(i,h,r,a,M,P):
    """"
    Returns s if s is in P and is non-zero.
    Returns 0 otherwise.

    Needed in rational_synthesis_xu.

    """
    B = 5
    ans = 0
    Pn0 = [x for x in P if x!=0]
    for s in Pn0:
        if s*(h[i]-a*r[i])%M**(i+B)==0:
            return s
    return 0

def adic_seq(u,q,x,N):
    """
    Returns N elements of the x-adic sequence for u/q,
    and u,q in least denominator form.

    Raises a ValueError if the denominator is divisible
    by the modulus x.

    EXAMPLES:
        sage: adic_seq(972,1001,10,15)
        (972, 1001, [2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9])
        sage: adic_seq(972,1001,10,20)
        (972, 1001, [2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7])
    
    """
    b = []
    b_seq = []
    G = gcd(u,q)
    u = ZZ(u/G)
    q = ZZ(q/G)
    if gcd(q,x) != 1: #check if the denominator is relatively prime to x
        raise ValueError, "After reduction of u and q, x and q are not relatively prime" 
    x = ZZ(x)
    N = int(N)
    for i in range(N):
        if i == 0:
            S = range(x)
        else:
            S = range(int(b_seq[i-1]),int(x^(i+1)),int(x^i))
        for j in S: 
            if (u-q*j)%x^(i+1) == 0:
                if i == 0:
                    b.append(ZZ(j))
                else:
                    b.append(ZZ((j-b_seq[i-1])/x^(i)))
                b_seq.append(ZZ(j))
    return u,q,b


def rational_synthesis_xu(As, M, verbose = False):
    """
    This outputs the rational which "best fits" the
    decimal expansion in a.

    INPUT:
         As - a list of k integers in [0,M-1]
         M - a modulus (such as 10)

    EXAMPLES:
        sage: adic_seq(972,1001,10,20)
        (972, 1001, [2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7])
        sage: rational_synthesis_xu([2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2], 10)
        (72849565132, 384693842281)
        sage: rational_synthesis_xu([2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9], 10)
        (10846647308, 62610590489)
        sage: rational_synthesis_xu([2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7], 10)
        (972, 1001)
        sage: rational_synthesis_xu([0,1,0,0,0,0,0],10)
        (10, 1)
        sage: rational_synthesis_xu([0,0,1,0,0,0,0],10)
        (100, 1)
        sage: rational_synthesis_xu([1,0,0,0],10)
        (1, 1)
        sage: rational_synthesis_xu([1,0,0],10)
        (-9, 91)
        sage: rational_synthesis_xu([2, 7, 8, 2, 1, 7, 8, 2, 1, 7, 8, 2, 1],10)
        (72, 101)
        sage: rational_synthesis_xu([2, 7, 8, 2, 1, 7, 8, 2, 1],10)
        (149711144, 196122577)

    QUESTION: Do you need 3 times the period to arrive with the
    correct answer?

    """
    k = len(As)
    B = 3
    P = interpolation_set(M)
    a = 1+M*sum([As[j]*M**j for j in range(k)])
    m = 0
    h = [0 for i in range(k+1)]
    r = [0 for i in range(k+1)]
    h[0] = 0; r[0] = 1
    h[1] = 1+M*sum([As[j]*M**j for j in range(B)])
    r[1] = 1+M**B
    for i in range(1, k):
        if verbose:
            print "start", numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
        if (h[i]-a*r[i])%(M**(i+1)) <> 0:
            s = ifsinP(i,h,r,a,M,P)
            t = 0
            if s<>0:
                h[i+1] = s*h[i]
                r[i+1] = s*r[i]
                if verbose:
                    print "type 1 update", i, numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
            else:
                s,t = findst(h[i]-r[i]*a,M**(i-m)*(h[m]-r[m]*a),i,M)
                h[i+1] = s*h[i]+t*M**(i-m)*h[m]
                r[i+1] = s*r[i]+t*M**(i-m)*r[m]
                if verbose:
                    print "type 2 update", i, numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
            cond1 = bool(height(h[i+1],r[i+1],M)>height(h[i],r[i],M))
            cond2 = bool(height(h[i],r[i],M) <= i-m+height(h[m],r[m],M))
            if (cond1 and cond2 and t<> 0):
                m = i
                if verbose:
                    print "turn updating", i, numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
        else:
              h[i+1] = h[i]
              r[i+1] = r[i]
    u = numerator((-1+(h[k]/r[k]))/M)
    q = denominator((-1+(h[k]/r[k]))/M)
    t = maxpower(u,q,M)
    return u/M**t,q/M**t

###################################################


"""
Sage implements in the module sage.crypto.boolean_function
several classes and methods for boolean functions.

We recall some background from [1].

A function $f$ on $GF(2)^n$ can be uniquely represented by
a polynomial on $GF(2)$ whose degree in each variable in each term is 
at most $1$. Namely,

\[
f (x_1 ,\dots , x_n ) =
\sum_{(a_1,\dots ,a_n)\in GF(2)^n}
g(a_1 ,\dots , a_n )x^{a_1}\cdot \dots \cdot x^{a_n},
\]
where $g$ is also a function on $GF(2)^n$. This polynomial 
representation of $f$ is called
the {\it algebraic normal form} (ANF) of the function.
The {\it algebraic degree} of $f$, denoted by $\deg(f )$,
is defined as the number of variables in the longest term 
of the ANF of $f$.


A Boolean function $f$ is said to be {\it balanced} if 
${\rm wt}(f ) = {\rm wt}(f + 1) = 2^{n-1}$. (Here $1$ denotes the 
constant function $1$ on $GF(2)^n$.
A {\it subfunction} of a Boolean function $f$ is a function $f$ 
obtained by substituting some constants for some variables in $f$.

The Boolean function $f$ is called 
{\it correlation immune of order $m$} if 
$[\rm wt}(f') = {\rm wt}(f )/2^m$ for any its subfunctions 
$f'$ of $n - m$ variables. 



If $\deg(f ) \leq 1$ then $f$ is called an {\it affine function}. 
If $f$ is an affine function and $f(0) = 0$ then $f$ is called a 
{\it linear function}.

For two Boolean functions $f_1$ and $f_2$ on $GF(2)^n$, 
we define the {\it distance} between $f_1$ and $f_2$ by 

\[
d(f_1 , f_2 ) = | \{x \in GF(2)^n \ |\ f_1 (x) \not= f_2 (x)\} |.
\]
(Here $|S|$ denotes the cardinality of a set $S$.)
The {\it weight} of a Boolean function is the distance between it
and the constant function $0$, denoted ${\rm wt}(f)$.
It is easy to see that 

\[
d(f_1,f_2)={\rm wt}(f_1+f_2).
\]
The minimum distance between $f$ and the set of all affine functions 
is called the {\it nonlinearity} of $f$ and denoted by 
$[\rm nl}(f )$.



The {\it Walsh transform} of a Boolean function $f$ is an integer-
valued function over $GF(2)^n$ that can be defined as

\[
W_f(u) =
\sum_{x in GF(2)^n}
(-1)^{f(x)+ \langle u,x\rangle}.
\]
The Walsh coefficients satisfy {\it Parseval’s equation}

\[
\sum_{x in GF(2)^n}
W_f(u)^2 = 2^{2n}.
\]


For any Boolean function $f$ on $GF(2)^n$, we have

\[
wt(f ) = 2^{n-1} - {\frac{1}{2}W_f(0),
\]
and
\[
{\rm nl}(f ) = 2^{n-1} - {\frac{1}{2}\max_{u \in GF(2)^n} |W_f (u)|.
\]


For each $u \in GF(2)^n$, the {\it autocorrelation coefficient} of the function 
$f$ at the vector $u$ is defined 

\[
\Delta_f(u) =
\sum_{x in GF(2)^n}
(-1)^{f(x)+ f(x+u)}.
\]

The {\it absolute indicator} of $f$ is defined as

\[
\Delta_f = \max_{u \in GF(2)^n-\{0\}} |\Delta_f (u)|.
\]

EXAMPLES:
    sage: from sage.crypto.boolean_function import *
    sage: P.<x0,x1,x2,x3> = BooleanPolynomialRing()
    sage: b = x0*x1 + x2*x3
    sage: f = BooleanFunction(b)
    sage: [b(x[0],x[1],x[2],x[3]) for x in GF(2)^4]
    [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0]
    sage: f.truth_table()
    (False, False, False, True, False, False, False, True, False, False, 
     False, True, True, True, True, False)
    sage: WT = f.walsh_hadamard_transform(); WT
    (-4, -4, -4, 4, -4, -4, -4, 4, -4, -4, -4, 4, 4, 4, 4, -4)
    sage: f.absolute_walsh_spectrum()
    {4: 16}
    sage: f.nonlinearity()
    6
    sage: 2^(4-1) - (1/2)*max([abs(x) for x in WT])
    6
    sage: f.autocorrelation()
    (16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    sage: f.absolute_autocorrelation()
    {16: 1, 0: 15}
    sage: f.absolut_indicator() # this is a mis-spelling in Sage
    0
    sage: f.is_bent()
    True
    sage: f.is_balanced()
    False
    sage: f.is_symmetric()
    False
    sage: f.sum_of_square_indicator()
    256
    sage: f.correlation_immunity()
    0


REFERENCES:
  [1] Yuriy Tarannikov, Peter Korolev, and Anton Botev, 
      {\it Autocorrelation coefficients and correlation immunity of Boolean 
      functions}, in {\bf Advances in Cryptology—ASIACRYPT 2001}. Available:
      \newline
      \url{http://www.iacr.org/cryptodb/data/paper.php?pubkey=515}



"""

def walsh_transform_1d(s,k):
    """
    This computes the Walsh(-Fourier) transform of the 
    sequence s of length n.
    
    INPUT:
        s - a sequence of n elements in GF(2), represented as a list
        k - an integer in the interval [0,n-1].

    EXAMPLES:
        sage: F = GF(2)
        sage: V = F^4
        sage: s = [F.random_element() for i in range(100)]
        sage: max([walsh_transform_1d(s,i) for i in range(100)])
        10
        sage: min([walsh_transform_1d(s,i) for i in range(100)])
        -14
        sage: s = [F.random_element() for i in range(10000)]
        sage: max([walsh_transform_1d(s,i) for i in range(100)])
        124
        sage: min([walsh_transform_1d(s,i) for i in range(100)])
        -16

    """
    n = len(s)
    terms = [(-1)^(s[i]+i*k) for i in range(n)]
    return sum(terms)

def walsh_transform(f, a):
    """
    This computes the Walsh(-Fourier) transform of the 
    Boolean function f on $GF(2)^n$ at $a \in GF(2)^n$.
    
    INPUT:
        s - a sequence of n elements in GF(2), represented as a list
        k - an integer in the interval [0,n-1].

    EXAMPLES:
        sage: F = GF(2)
        sage: V = F^4
        sage: f = bent_function_standard
        sage: a = V([1,0,1,1])
        sage: walsh_transform(f, a)
        -4
        sage: a = V([0,0,0,0])
        sage: walsh_transform(f, a)
        4
        sage: WT = [walsh_transform(f, a) for a in V]; WT
        [4, 4, 4, -4, 4, 4, 4, -4, 4, 4, 4, -4, -4, -4, -4, 4]
        sage: 2^(4-1) - (1/2)*max([abs(x) for x in WT])
        6

    WARNING: This seems to differ by a sign from the method
    walsh_hadamard_transform in sage.crypto.boolean_function.

    """
    F = a[0].parent()
    n = len(a)
    terms = [(-1)^(f(x)+x.dot_product(a)) for x in F**n]
    return sum(terms)

def bent_function_standard(x):
    """
    This function returns the value of a bent function at x.
    The bent function is constructed using the "simplest" 
    construction [1].

    INPUT:
        n - an even integer >= 4
        x - an element of GF(2)^n

    EXAMPLES:
        sage: V = GF(2)^4
        sage: s = [bent_function_standard(x) for x in V]
        sage: s
        [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0]


    REFERENCES:
        [1] http://en.wikipedia.org/wiki/Bent_function

    """
    n = x.degree()
    if n<1 or n%2 <> 0:
        raise ValueError("%s must be a positive even integer"%n)
    m = int(n/2)
    terms = [x[2*i]*x[2*i+1] for i in range(m)]
    return sum(terms)
    
def bent_function_MM(x, M = identity_matrix(GF(2), int(len(x)/2)), g = lambda x: GF(2)(0) ):
    """
    This function returns the value of a bent function at x.
    The bent function is constructed using the Maiorana-McFarland
    construction [1].

    INPUT:
        n - an even integer >= 4
        x - an element of GF(2)^n
        M - an invertible n/2 x n/2 matrix over GF(2)
        g - a boolean function on GF(2)^(n/2)

    EXAMPLES:
        sage: V = GF(2)^4
        sage: s = [bent_function_MM(x) for x in V]
        sage: s
        [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0]
        sage: [walsh_transform(s, k) for k in range(2^4)]
        [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]
        sage: V = GF(2)^8
        sage: M = GL(4, GF(2)).random_element(); M
        [0 0 1 1]
        [1 1 0 1]
        [1 0 1 0]
        [1 0 0 0]
        sage: g = lambda x: bent_function_standard(x) 
        sage: s = [bent_function_MM(x, M, g) for x in V]
        sage: len(s)
        256
        sage: [walsh_transform(s, k) for k in range(2^8)]
        [16, ..., 16]

    REFERENCES:
        [1] C. Carlet, "Boolean Functions for Cryptography and 
            Error Correcting Codes," preprint (available on www).

    """
    n = x.degree()
    if n<1 or n%2 <> 0:
        raise ValueError("%s must be a positive even integer"%n)
    m = int(n/2)
    V = GF(2)^m
    v1 = V([x[i] for i in range(m)])
    v2 = V([x[i] for i in range(m,n)])
    return v1*M*v2+g(v2)

###################################################

def boolean_fcn_synthesis(f, n, p):
    """
    Returns rational number whose p-adic expansion matches the values of 
    f:GF(p)^n -> GF(p).

    INPUT:

    EXAMPLES:
        sage: f = lambda x: x[0]*x[1]+x[2]*x[3]
        sage: boolean_fcn_synthesis(f, 4, 2)
        -30856/65535
        sage: boolean_fcn_synthesis(f, 4, 3)
        -158298070546506595701961644853448561652/221713244121518884974124815309574946401
        sage: V = GF(2)^3
        sage: V.list()
        [(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), (0, 0, 1), (1, 0, 1), (0, 1, 1), (1, 1, 1)]
        sage: f = lambda x: x[0]               
        sage: boolean_fcn_synthesis(f, 3, 2)
        -2/3
        sage: f = lambda x: x[2]
        sage: boolean_fcn_synthesis(f, 3, 2)
        -16/17
        sage: adic_seq(-16, 17, 2, 15)
        (-16, 17, [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1])
    """
    F = GF(p)
    V = GF(p)**n
    return (1-p**(p**n))**(-1)*sum([int(f(V[j]))*p**j for j in range(p**n)])

def ANF_coef(BF,N):
	V=GF(2)^N
	coef=V(BF)
	if N==1: 
		return list(coef)
	for i in range(N/2):
		coef[i+N/2]=coef[i]+coef[i+N/2]
	coef_final=ANF_coef(list(coef[0:N/2]),N/2)+ANF_coef(list(coef[N/2:N]),N/2)
	return coef_final

def ANF(BF,N):
	from sage.crypto.boolean_function import BooleanFunction
	coef=ANF_coef(BF,N)
	vars='x0'
	for i in range(1,log(N,2)):
		vars=vars+',x'+str(i)
	R=BooleanPolynomialRing(log(N,2),vars)
	x=R.gens()
	poly=x[0]-x[0]
	poly=BooleanFunction(poly)
	for i in range(N):
		n=ZZ(i).digits(base=2,padto=log(N,2))
		next_term=BooleanFunction(coef[i]*x[0]^n[0])
		for j in range(1,log(N,2)):
			next_term=next_term*BooleanFunction(x[j]^n[j])
		poly=poly+next_term
	return poly
