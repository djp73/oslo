"""
Algebraic feedback shift register functions



AUTHOR:
   David Joyner, wdjoyner@gmail.com, 2011-10-19
   Charles Celerier, charles.celerier@gmail.com

LICENSE:
   Modified BSD

"""

def connection_element(Qs, p):
    """
    Input consists of 
        Qs - r+1 elements from T ("taps")
        p - prime

    This function returns the connection element

    EXAMPLES:
        sage: p = 5; Qs = [2,2,1,2]
        sage: connection_element(Qs, p)
        283

    """
    r = len(Qs)-1
    c = -Qs[0]+sum([Qs[i]*p**i for i in range(1,r+1)])
    return c


def generating_quotient(As, Qs, m, p):
    """
    Input consists of 
        S, T - complete sets of reps mod p
        As - r elements from S
        Qs - r+1 elements from T
        m - integer
        p - prime
        N - positive integer > r

    This function returns

    EXAMPLES:
        sage: p = 5; Qs = [2,2,1,2]; As = [1,2,2]; m = 4
        sage: generating_quotient(As, Qs, m, p)
        -487/283
        sage: alpha = Qp(5)(-487/283)
        sage: alpha.padded_list(20)
        [1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 0, 0, 3, 0, 2, 0, 2, 4, 0, 0]

    This gives the same output as afsr does.

    """
    r = len(Qs)-1
    DS = sum([sum([Qs[i]*As[n-i]*p**n for i in range(1,n+1)]) for n in range(1,r)])
    u = -m*p**r - Qs[0]*sum([As[i]*p**i for i in range(r)]) + DS
    return u/connection_element(Qs, p)


def afsr(S, T, As, Qs, m, p, N):
    """
    Input consists of 
        S, T - complete sets of reps mod p
        As - r elements from S
        Qs - r+1 elements from T
        m - integer
        p - prime
        N - positive integer > r

    This function returns a list of length N generated
    by the AFSR associated to (S, T, As, Qs, m, p), as in [KX]
  
    EXAMPLES:
        sage: p = 5; N = 20; S = range(p); T = S
        sage: As = [1,2,2]; Qs = [1,2,1,2]; m = 4
        sage: afsr(S, T, As, Qs, m, p, N)
        [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
        sage: As = [1,2,2]; Qs = [2,2,1,2]; m = 4
        sage: afsr(S, T, As, Qs, m, p, N)
        [1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 0, 0, 3, 0, 2, 0, 2, 4, 0, 0]
        sage: Qp(5)(-487/283)
         1 + 2*5 + 2*5^2 + 5^3 + 5^5 + 5^7 + 2*5^8 + 3*5^12 + 2*5^14 + 2*5^16 + 4*5^17 + O(5^20)
        sage: alpha.padded_list(20)
        [1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 0, 0, 3, 0, 2, 0, 2, 4, 0, 0]
        sage: multiplicative_order(mod(5,283)) # the period
        282


    REFERENCE:
        [KX] Klapper and Xu, "Algebraic feedback shift registers",
             Theoretical Com. Sci., vol 226, 1999,
             http://www.cs.uky.edu/~klapper/papers.html

    """
    r = len(As)
    # test if S and T will work
    if len(S) <> p:
        raise NameError("arg S is not a complete set of reps mod ", p)
    if len(T) <> p:
        raise NameError("arg T is not a complete set of reps mod ", p)
    Zp = IntegerModRing(p)
    S0 = [Zp(s) for s in S]
    S0.sort()
    if S0 <> [Zp(x) for x in range(p)]:
        raise NameError("arg S is not a complete set of reps mod ", p)
    T0 = [Zp(t) for t in T]
    T0.sort()
    if T0 <> [Zp(x) for x in range(p)]:
        raise NameError("arg T is not a complete set of reps mod ", p)
    # test if As are in S
    for x in As:
        if not(x in S):
            raise NameError("arg As is not a set of fills for ", S)
    # test if Qs are in T
    for x in Qs:
        if not(x in T):
            raise NameError("arg Qs is not a set of taps for ", T)
    if len(Qs) <> r+1:
        raise NameError("arg Qs is not a set of taps for ", T)
    # force m to be an initial memory value
    m = ZZ(m)
    # force p to be a prime
    p = next_prime(p-1)
    # force N to be an integer
    N = ZZ(N)
    conn_elmt = -Qs[0]+sum([Qs[i]*p**i for i in range(1,r+1)])
    newAs = As
    new_m = m
    a = S[0]
    if N <= r:
        return As
    for j in range(N-r):
        tau = sum([Qs[i]*newAs[-i] for i in range(1,r+1)]) + new_m
        for s in S:
            if Zp(tau) == Zp(s*Qs[0]):
                newAs.append(s)
                new_m = ZZ((tau-s*Qs[0])/p)
                #print j, tau, s, new_m, r
    return newAs


def adic_seq2(u, q, p, N): 
    """
    Input consists of 
        u, q - positive integers (q<p^(20))
        p - positive integer
        N - positive integer > r

    This function returns a triple:
     -  u,q in least denominator form,
     -  a list of length N generated by the AFSR associated 
        to (u, q, p), as in Theorem 10, [KX])
  
    EXAMPLES:
        sage: adic_seq(u, q, p, N)
        (972, 1001, [2, 4, 3, 1, 1, 4, 0, 4, 0, 3, 1, 3, 4, 1, 3, 2, 4, 2, 3, 3])
        sage: afsr2(u, q, p, N)
        (972, 1001, [2, 4, 3, 1, 1, 4, 0, 4, 0, 3, 1, 3, 4, 1, 3, 2, 4, 2, 3, 3])

    REFERENCE:
        [KX] Klapper and Xu, "Algebraic feedback shift registers",
             Theoretical Com. Sci., vol 226, 1999,
             http://www.cs.uky.edu/~klapper/papers.html

    """
    S = range(p)
    U = range(q)
    G = gcd(u,q)
    u = ZZ(u/G)
    q = ZZ(q/G)
    gamma = 1
    for i in U:
        if i*p%q==1:
            gamma = i
    rho = 1
    for i in S:
        if i*q%p==1:
            rho = i
    aseq=[];useq=[];j=0;
    useq+=[(u*gamma**k)%q-q for k in range(N)]
    while (u%(p**(j+1))==0 and  u>=0):
        aseq+=[0]
        j+=1
    aseq+=[rho*((u*gamma**j)%q)%p]
    aseq+=[rho*useq[k]%p for k in range(j+1,N)]
    return u,q,aseq

#######################################

def index(x,M):
    """
    Inputs a non-zero integer and outputs the 
    integer part of its log.

    """
    return int(log(abs(x))/log(M))

def height(x,y,M):
    """
    Inputs a pair of non-zero integers and outputs the 
    max of the integer part of their log.

    """
    return int(max(log(abs(x))/log(M),log(abs(y))/log(M)))

def interpolation_set(M):
    """
    Returns the interpolation set associated to the 
    modulus M.

    """
    if M==2:
        L = 5
    if M==3:
        L = 15
    if M>3:
        L = int(M**3/2)
    return range(-L,L+1)

def findst(h1,h2,i,M):
    """
    Solves h1*s+h2*t = 0 mod M^5.


    """
    P = interpolation_set(M)
    for s in P:
        for t in P:
            if (s*h1+t*h2)%M**(i+5) == 0:
                return (s,t)

def maxpower(u,q,M):
    """
    Returns max power of M dividing u,q

    EXAMPLES:
        sage: maxpower(1000, 200, 10)
        2
        sage: maxpower(1200,9,9)
        0


    """
    r = gcd(u,q)
    m = int(log(r,M))
    for t in range(2*m):
        if r%M**t != 0:
            return t-1
    return 0

def ifsinP(i,h,r,a,M,P):
    """"

    """
    B = 5
    ans = 0
    Pn0 = [x for x in P if x!=0]
    for s in Pn0:
        if s*(h[i]-a*r[i])%M**(i+B)==0:
            return s
    return 0

def adic_seq(u,q,x,N):
    """
    Returns N elements of the x-adic sequence for u/q,
    and u,q in least denominator form.

    Raises a ValueError if the denominator is divisible
    by the modulus x.

    EXAMPLES:
        sage: adic_seq(972,1001,10,15)
        (972, 1001, [2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9])
        sage: adic_seq(972,1001,10,20)
        (972, 1001, [2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7])
    
    """
    b = []
    b_seq = []
    G = gcd(u,q)
    u = ZZ(u/G)
    q = ZZ(q/G)
    if gcd(q,x) != 1: #check if the denominator is relatively prime to x
        raise ValueError, "After reduction of u and q, x and q are not relatively prime" 
    x = ZZ(x)
    N = int(N)
    for i in range(N):
        if i == 0:
            S = range(x)
        else:
            S = range(int(b_seq[i-1]),int(x^(i+1)),int(x^i))
        for j in S: 
            if (u-q*j)%x^(i+1) == 0:
                if i == 0:
                    b.append(ZZ(j))
                else:
                    b.append(ZZ((j-b_seq[i-1])/x^(i)))
                b_seq.append(ZZ(j))
    return u,q,b


def xu(As, M):
    """
    This outputs the rational which "best fits" the
    decimal expansion in a.

    INPUT:
         As - a list of k integers in [0,M-1]
         M - a modulus (such as 10)

    EXAMPLES:
        sage: adic_seq(972,1001,10,20)
        (972, 1001, [2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7])
        sage: xu([2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2], 10)
        (72849565132, 384693842281)
        sage: xu([2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9], 10)
        (10846647308, 62610590489)
        sage: xu([2, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7, 9, 8, 2, 0, 1, 7], 10)
        (972, 1001)
        sage: xu([0,1,0,0,0,0,0],10)
        (10, 1)
        sage: xu([0,0,1,0,0,0,0],10)
        (100, 1)
        sage: xu([1,0,0,0],10)
        (1, 1)
        sage: xu([1,0,0],10)
        (-9, 91)
        sage: xu([2, 7, 8, 2, 1, 7, 8, 2, 1, 7, 8, 2, 1],10)
        (72, 101)
        sage: xu([2, 7, 8, 2, 1, 7, 8, 2, 1],10)
        (149711144, 196122577)

    QUESTION: Do you need 3 times the period to arrive with the
    correct answer?

    """
    k = len(As)
    B = 3
    P = interpolation_set(M)
    a = 1+M*sum([As[j]*M**j for j in range(k)])
    m = 0
    h = [0 for i in range(k+1)]
    r = [0 for i in range(k+1)]
    h[0] = 0; r[0] = 1
    h[1] = 1+M*sum([As[j]*M**j for j in range(B)])
    r[1] = 1+M**B
    for i in range(1, k):
        #print "start", numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
        if (h[i]-a*r[i])%(M**(i+1)) <> 0:
            s = ifsinP(i,h,r,a,M,P)
            t = 0
            if s<>0:
                h[i+1] = s*h[i]
                r[i+1] = s*r[i]
                #print "type 1 update", i, numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
            else:
                s,t = findst(h[i]-r[i]*a,M**(i-m)*(h[m]-r[m]*a),i,M)
                h[i+1] = s*h[i]+t*M**(i-m)*h[m]
                r[i+1] = s*r[i]+t*M**(i-m)*r[m]
                #print "type 2 update", i, numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
            cond1 = bool(height(h[i+1],r[i+1],M)>height(h[i],r[i],M))
            cond2 = bool(height(h[i],r[i],M) <= i-m+height(h[m],r[m],M))
            if (cond1 and cond2 and t<> 0):
                m = i
                #print "turn updating", i, numerator((-1+(h[i]/r[i]))/M), denominator((-1+(h[i]/r[i]))/M)
        else:
              h[i+1] = h[i]
              r[i+1] = r[i]
    u = numerator((-1+(h[k]/r[k]))/M)
    q = denominator((-1+(h[k]/r[k]))/M)
    t = maxpower(u,q,M)
    return u/M**t,q/M**t

###################################################

