\section{Introduction}
\par Finite state machines are useful for generating
periodic sequences. These machines are composed of
inputs, states, outputs, and a set of rules that
determine outputs based on the current state and input.
A shift register is a type of finite state machine that
has a feedback function for its input based on the state
of the machine. This feedback is what drives the autonomous
behavior of the machine. The two general type of shift
registers are linear feedback shift registers (LFSRs) and
feedback with carry shift registers (FCSRs). The difference
between the two types of registers is that the FCSR uses
a memory cell for its input that remembers feedback from
previous states. Inputs for the LFSR are only based on a
function of the previous states. This paper will consider
the generated sequences of FCSRs.

\par For an FCSR to be a useful stream cipher, it must
produce sequences that are unpredictable if only a small
portion of the sequence is known. To analyze the
predictability of the output of an FCSR, this paper follows
the work of Dr. Andrew Klapper and Dr. Mark Goresky by using
$N$-adic integers, $\zzzn$ to represent the $N$-ary sequences
generated by FCSRs. A property of the $N$-adic integers
is that any eventually periodic sequence can be represented
by the a rational number $b/a\in\zzzn$ where $a$ is
relatively prime to $N$. Since FCSRs are finite state
machines, their output is eventually periodic, which means
the sequences generated by FCSRs can always be represented
by rational numbers in $\zzzn$.

\par Register synthesis algorithms are used to recover the
state of an FCSR from the generated sequence. These
algorithms make use of the fact that eventually periodic
$N$-adic integers can represent the sequences generated by
FCSRs. The goal of this paper is to first lead the reader through
the background of $N$-adic integers and FCSRs, and then
explain a register synthesis algorithm that will be
implemented using a Python script in the open source
algebraic computer system SAGE.

%\par Ultimately, this paper aims to demonstrate the use
%of a register synthesis algorithm to recover the state
%of a stream ciphers constructed around feedback with carry
%shift registers (FCSRs). First, the reader must understand
%some preliminary knowledge about cryptology.
%
%\par Symmetric cryptography can be divided into two
%categories of ciphers: block ciphers and stream ciphers.
%{\em Block ciphers} are used for encrypted large block
%of plaintexts data while {\em stream ciphers} encrypt
%single plaintext characters at a time. The classic example
%of a block cipher is the Caesar cipher where each plaintext
%character is shifted forward by three character in the
%alphabet. That particular cipher is susceptible to many
%different type of attack. An easy one is the shift the
%ciphertext through the entire alphabet and then pick the
%shift which results in intelligible plaintext. A stream
%cipher looks more like a one-time pad where a stream of
%shift numbers would be produced and then the plaintext
%characters would be shifted through the alphabet
%according to the sequence of shift numbers. Of course,
%to be a true one-time pad the stream cipher would have to
%generate a truly random sequence of shift numbers.
%
%\par In Rainer Rueppel's paper ``Stream Ciphers'' he writes,
%``a major goal of stream cipher design is to produce
%random-looking sequences.'' For use with a lot of plaintext
%randomness is extremely, but for keystream generation
%it sufficient to produce sequences that are unpredictable
%from short prefixes, as noted by Andrew Klapper and Mark
%Goresky in their the introduction of their book
%{\em Algebraic Shift Register Sequences}. In practice,
%stream ciphers use short pieces of plaintext that may
%be the key for block cipher or the sequence may be the
%actual key used for a block cipher.
%
%\par Shift registers can generate sequences with extremely long
%periods that have desirable randomness properties. 
%
